<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Intro to hadoop and MapReduce -- Note(一)]]></title>
      <url>%2F2017%2F04%2F04%2Fbig-data%2F</url>
      <content type="text"><![CDATA[Definition of Big Data可能有些人认为几个terebytes的数据量是大数据，但这个量不是标准的，所以一个合理的定义是 It’s data that’s too big to be processed on a single machine. Quiz: Chanllenges with Big Data- most data is worthless data is created fast data from different sources in various formats most data is not worthless, but actually does have a lot of value. The 3 V’s of big dataVolume总结：量大。需要考虑那些能提供有用信息 But in order to store it, you’ll need a way to scale your storage capacity up to massive volume. Hadoop, which stores data in a distributed way across multiple machines, does that Variety就是说我们如果用像MySQL,Oracle这种数据库，数据必须要适合他们的格式，但是现在我们处理的数据很大部分都是unstructured或者是semi-structured.比方说现在打客服热线不都有一个提示说是会录音，一种存储是语音识别成文字保存起来，另一种是直接存储成mp3格式然后让相应的软件解码如果后面要用的话。那hadoop不管你的数据是什么样的格式， you can just store the data in its raw format, and manipulate and reformat it later. example Sometimes the most unlikely data can be extremely useful and lead to savings due to better planning. 比方说现在要通知附近的货车到中心取货，基于位置的系统就会通知最近的车辆过来。但往往，这个最近，不是最佳的选择。也许那里有交通堵塞，也许最近的车辆过来需要过羊肠小道，那里的路比较难走，也许是要绕一大圈才能到中心。更需要考虑的是，这辆车上也许没有足够的空间了，这辆车没有油了。所以以下都是需要考虑的 Current GPS location fromi all trucks Current itineraries for all trucks Current traffic speed in related areas as reported by services such as waze Current load of trucks by volume and weight Fuel efficiency of the different vehicles The world we live in is extremely complex, and there are a lot of variables to consider that you can tweak to get large benefits. Velocity实时更新？？If we can’t store it as it arrives, we’ll end up discarding some of it, and that’s what we absolutely want to avoid. history of hadoop来自hadoop 之父 Doug Cutting So, let me tell you how Hadoop came to be. About ten years ago in around 2003, I was working on an Open Source web search engine called Nutch, and we knew it needed to be something very scalable, because the Web was you know, billions of pages. terabytes, petabytes, of data, that we needed to be able to process, and we set about doing the best job we could and it was tough. We got things up and running on four or five machines, not very well, and around that time Google published some papers about how they were doing things internally. Published a paper about their distributed file system, TFS. and about their processing, framework, MapReduce. So my partner and I, at the time, in this project, Mike Cafarella. said about trying to reimplement these in Open Source. So that more people could use them than just folks at Google. Took us a couple of years, and we had Nutch up and running on, instead of four or five machines, on, 20 to 40 machines. It wasn’t perfect, it wasn’t totally reliable, but it worked. And we realize that to get it to the point where it was scaled to thousands of machines, and be as bullet proof as it needed to be, would take more than just the two of us, working part time. Around that time, Yahoo approached me and said they were interested in investing in this. So I went to work for Yahoo in January of 2006. First thing I did there, was, we took the parts of Nutch that were a distributed computing platform, and put them into a separate project. A new project christened Hadoop. Over the next couple years, with, Yahoo’s help, and the help of others, we took Hadoop, and really got it to the point where it did scale to petabytes, and running on thousands of processors. And doing so quite reliably. It spread to lots of companies, and mostly in the Internet sector, and became quite a success. after that, we, we started to see a bunch of other projects grow up around it. And Hadoop’s grown to be the kernel of a, which, pretty much an operating system for big data. We’ve got tools that, allow you to, more easily do, MapReduce programming, so, you can develop using SQL or a data flow language called Pig. And we’ve also got the beginnings of higher­level tools. We’ve got interactive SQL with Impala. We’ve got Search. and so we’re really seeing this develop to being a general purpose platform for data processing. that scale’s much better and that it is much more flexible than anything that’s, that’s, else is out there. hadoop clusterhadoop存储数据的方法是一个分布式的文件系统叫做HDFS。处理数据是通过MapReduce。核心思想就是将数据分块，然后在集群中存储，也就是各个计算机搭建的一个网络吧。那这样的好处就是我们不用从中心取数据然后再操作，我们直接在集群中就地处理数据，后续还可以继续扩大集群的规模 hadoop Ecosystem Core hadoop consists of HDFS and MapReducehadoop的生态系统。以hadoop为核心的，打造的周边产品，主要的目的就是降低使用hadoop的难度和门槛。比如编写MapReduce的程序不是一件容易的事，有些没有编程经验的就可以用Pig，Hive，这种类似SQL语句来操作数据，但这两个都是将语句翻译为MapReduce然后再到集群上执行。因为Hive和Pig它们本质上还是MapReduce的工作量，所以花费的时间可能更多。所以另一个开源项目Impala，它是允许直接用SQL语句来操作数据，不用经过MapReduce（具体现在我也不懂），所以这样就很快了其他的也就类似了。 Cloudera hadoop版的其实就是把这些都给你打包好了，你不用在一个一个去弄了。 核心还是hadoop的HDFS和MapReduce]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seven-principle]]></title>
      <url>%2F2017%2F04%2F04%2Fseven-principle%2F</url>
      <content type="text"><![CDATA[自带鸡血，能源源不断地给自己充电，遇到打击能迅速恢复，哪怕这种打击沉重而有力，也就是，抗压能力强。 不能给自己设限，既没有上限，也没有下限，凡事能想到的事，都敢做，给联合国秘书长写信也没啥不敢的 格局大，顺势而为.胸怀达到全宇宙，又能找到把猪吹上天的风口，从来站在更大的地位上思考问题，绝不想同事蹭吃了一盒酸奶之类的小时； 对自己高标准，永不满足，一旦自己陷入舒适圈，马上调整自己，给自己提更高的要求，让自己不舒适，让自己不高心，让自己不痛快，给自己找别扭，上升到更高的level 做不可替代的角色 极度自律，执行力超强（强调）。别跟我说自律，其实就是一个人呆着的时候，不放纵自己，做应当做的是，不玩游戏，不看电视剧，不在低附加值的事情上浪费时间。同时，你不能想着，我要有时间就好了，然后每天还能睡到中午12点，然后慵懒的发发朋友圈，谈谈诗和远方。 具备逆向思维，善于创新，说白了，就不跟大家一样思考，常人怎么想，总是反着想，具备创新精神。剑走偏锋]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自我约束-1]]></title>
      <url>%2F2017%2F03%2F30%2Fself-discipline%2F</url>
      <content type="text"><![CDATA[坐公交好几次都碰见她，一位穿着比较啰哩啰嗦的，时尚的。我想认识她 今天，我在看nba勇士队的比赛，她突然过来，没有一丝丝准备，都不知道我发型有没有乱的，问我能不能帮她刷下公交卡，她转支付宝给我，我下意识的说不用，现在老后悔了。 不过，从我过往的经验看，大多是我自己自作多情，人家也只是想寻求帮助，不要想太多了，今天不是你也是其他人。 但还是挺开心的，借此聊了一会，得知是大三外语系的。哈哈哈 这次的自我约束：如果你能静下心来，不要胡思乱想。进入自己的zone, 认认真真做自己的事情，专注！！看缘分，如果能做到专注，那么下次遇见的时候就厚着脸皮要个联系方式吧，不然就永远当个路人]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python name and values]]></title>
      <url>%2F2017%2F03%2F29%2Fpython-name-and-values%2F</url>
      <content type="text"><![CDATA[阅读 Facts and myths about Python names and values 做的摘记内容不是很深，只是这里面提到了一些需要注意的点。最主要还是name和value的区别 Fact: Names have no type, values have no scope. Just as names have no type, values have no scope. When we say that a function has a local variable, we mean that the name is scoped to the function: you can’t use the name outside the function, and when the function returns, the name is destroyed. But as we’ve seen, if the name’s value has other references, it will live on beyond the function call. It is a local name, not a local value. 翻译： 就跟名字没有类型一样，数值是没有作用范围的。当我们说一个函数有局部变量的时候，我们只是说的是名字只在函数作用域中起作用而已，你不能在函数外使用这个名字，当函数返回的时候，这个名字也就摧毁了。但是，如果这个名字指向的数值还有其他引用，它就会继续生存下去，不管这个函数了。局部变量，而不是局部数值。 Fact: Values can’t be deleted, only names can. Python’s memory management is so central to its behavior, not only do you not have to delete values, but there is no way to delete values. You may have seen the del statement: 12nums = [1, 2, 3]del nums This does not delete the value nums, it deletes the name nums. The name is removed from its scope, and then the usual reference counting kicks in: if nums’ value had only that one reference, then the value will be reclaimed. But if it had other references, then it will not. Fact: Assignment never copies data. Mutable means that the value has methods that can change the value in-place. Immutable means that the value can never change, instead when you think you are changing the value, you are really making new values from old ones. 比如：12x = 3y = x x和y只是一起指向了3而已，并没有给y再来一个3。这里x,y是name，3是value上面说到的Mutable是什么意思，也就是因为这个赋值不拷贝数据的特性，当y变了的时候，比如y+=1，那x还变不变？这里就要考虑到可变类型和不可变类型了 Immutable values: numbers strings tuples Mutable values: lists dicts user-defined objects 那在上面y+=1之后，其实是给y重新reference到了4 关于mutable的直接截图： Fact: Python passes function arguments by assigning to them.123def my_func(x,y) return x+yprint(my_func(8,9)) The names x and y are local to the function, so when the function returns, those names go away. But if the values they refer to are still referenced by other names, the values live on. 注意，这里就出现name和value的区别了，可以这样理解，value就是一个实物，name只是这个实物的标签，我可以贴很多标签，而看到这个标签，我就联想到这个实物，实物可以有多个标签，一个标签只能对应一个实物。 1234567def augment_twice(a_list,val): a_list.append(val) a_list.append(val)nums = [1,2,3]augment_twice(nums, 4)print(nums) #[1,2,3,4,4] 虚线框表示本地name在一个新的frame里面，而参数传递只是一种赋值操作，a_list “指向” nums指向的value,而list类型是可变数据类型，所以任何name对它的改变都是就地的，可以通过id()操作来查看是否改变了地址 另外一个程序 12345def augment_twice_bad(a_list,val): a_list = a_list + [val,val]nums = [1,2,3]augment_twice_bad(nums,4)print(nums) #[1,2,3] 这个跟上面的程序就不同在函数里面一个是用.append()来增加元素，一个则用加法然后赋值，赋值，赋值，重要的事情说三遍，这是个赋值操作，一旦出现赋值，就相当于等式左边的namerebind出现在等式右边的value It’s really important to keep in mind the difference between mutating a value in place, and rebinding a name. augment_twice worked because it mutated the value passed in, so that mutation was available after the function returned. augment_twice_bad used an assignment to rebind a local name, so the changes weren’t visible outside the function. 其他的 facts, myths都知道了，上面的需要注意一下就可以了。过]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[naruto]]></title>
      <url>%2F2017%2F03%2F20%2Fnaruto%2F</url>
      <content type="text"><![CDATA[迈特凯语录 唯有努力，我不想输给他 真正的胜利，不是击败强者，而是保护对你而言最重要的东西。 不相信自己的人，连努力的价值都没有。 真正重要的东西，不管痛苦也好、悲伤也好…都要努力到底，就算失去生命也要用双手来保护到底!如此一来，就算死掉的话，也会永远留下男子汉活过的证据… 努力是绝不会背叛人的 你只要相信自己所走的路，大步向前走就好，然后就那样成为一个能让别人带着笑容守望着的人吧。 天资聪颖的人并非幸福，能够为自己所信任之人去努力拼搏的人才是幸福的！ 当新叶萌发，新春到来之时，才是青春的最高潮燃烧得最火热的时刻！ 既然我已经摆出帅哥的姿势来耍帅了,就必须要彻底地遵守约定! 小李,你要休息了吗? 青春的勋章离不开『热血』 我相信木叶的莲花一定会再次定放!! 青春的操场500圈!! 这就是青春!!! 在凯开八门遁甲，这个差点一脚踢出大结局的男人，令卡卡西尊敬不已，我反复看了好几遍。凯这个集逗逼与热血气质于一身的男人。 迈特凯父亲，迈特戴的语录 不要和你的努力说对不起，那样会多对不起你的努力啊！ 祝贺你从忍者 学校毕业，但青春可不能就此毕业啊。搜索青春什么时候结束？青春不会退缩，所以永远不会结束。那爸爸死的时候也不结束吗？那才是青春的最高潮！ 迈特戴：不过你的努力也不算错，就算只跑完一半，你也确实努力了。 迈特戴：你的忍术和体术不行，这才叫爸爸高兴，知道自己的短处，才能让长处发光， 迈特戴：爸爸很高兴，能让儿子在这么小的时候就发现长处， 迈特凯：爸爸，其实你在逞强吧， 迈特戴：短处也能变成长处，唠叨代表周到，啰嗦说明热门，顽固意味着专注， 迈特戴：所谓自我约束是指在向某些困难发起挑战时，故意给自己戴上一个枷锁，把自己逼到穷途末路， 制定只属于自己的规矩，正因为有了那个枷锁，你才会认真面对挑战，而一旦失败，你就能通过实践那个规矩，让自己得到严格的锻炼，使得自己不断进步，这才叫自我约束。 迈特戴为迈特凯的父亲，他影响了迈特凯的一生，而迈特凯也将这种影响传给了自己的徒弟李洛克 青春，热血！！！ 迈特戴经常在别人嘲笑他的时候，对别人说，谢谢支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[project of stackoverflow - python object(一)]]></title>
      <url>%2F2017%2F03%2F14%2Fobject%2F</url>
      <content type="text"><![CDATA[what does ‘super’ do in python下面两个的区别是？ 123class Child(SomeBaseClass): def __init__(self): super(Child, self).__init__() 和123class Child(SomeBaseClass): def __init__(self): SomeBaseClass.__init__(self) 我在单个继承中已经看到super 被用的很多了。我能知道为什么要在多重继承的时候用它，但是还是不清楚在这种情况用它的好处。 180票的回答：（John Millikin) 在单一继承用super的好处很小–只是你不再需要硬编码基类名字到方法里面去了 然后，在多重继承里，不用super()几乎是不可能的。这包括常见的习语，像是mixins，interface,abstract classes等，这能让你的代码在之后延伸。如果以后有人想写一个拓展Child 和 mixin的类，他们的代码不会很好的工作。 75票的回答： 区别是什么？ SomeBaseClass.__init__(self)意思是调用SomeBaseClass的__init__方法然后，super(Child,self).__init__()意思是从Child类的MRO的父类中调用一个绑定方法__init__如果实例是Child的子类，有可能在方法解释顺序中的下一个父类是不一样的？？？ 向前兼容间接 ？？ （Indirection with Forward Compatibility) 这能给你什么？对于单重继承，问题中给出的例子几乎等同于静态分析。然而使用super 提供了具有向前兼容性的间接层向前兼容对于经验丰富的开发者来说是很重要的。你希望你的代码在做出一些细微的改动之后还能工作。当您查看修订历史记录时，您希望准确地查看何时更改了哪些内容。 你可能先从单重继承开始，但是当你增加另外的基类，你只需要改变基类的顺序（change the line with the bases）（if the bases change in a class you inherit from）如果类继承关系变了（比如增加了一个mixin)，其实你就没做什么改变。尤其在python2中，要想给super正确的方法参数是很难的。如果你知道你在单重继承下正确的使用super，这样是的调试就容易一点了 依赖注入 Dependency Injection 其他人可以使用你的代码然后插入一些父类到方法解释中(method resolution): 12345678910111213class SomeBaseClass(object): def __init__(self): print('SomeBaseClass.__init__(self) called') class UnsuperChild(SomeBaseClass): def __init__(self): print('UnsuperChild.__init__(self) called') SomeBaseClass.__init__(self) class SuperChild(SomeBaseClass): def __init__(self): print('SuperChild.__init__(self) called') super(SuperChild, self).__init__() 现在你增加其他类，然后在Foo和Bar之间插入一个类 12345678class InjectMe(SomeBaseClass): def __init__(self): print('InjectMe.__init__(self) called') super(InjectMe, self).__init__() class UnsuperInjector(UnsuperChild, InjectMe): pass class SuperInjector(SuperChild, InjectMe): pass 使用un-super子类未能注入依赖，因为你是用的子类在自己执行打印后调用的是硬编码方法 123&gt;&gt;&gt; o = UnsuperInjector()UnsuperChild.__init__(self) calledSomeBaseClass.__init__(self) called 然而使用super的子类能正确的依赖注入 1234&gt;&gt;&gt; o2 = SuperInjector()SuperChild.__init__(self) calledInjectMe.__init__(self) calledSomeBaseClass.__init__(self) called (我：因为super按照MRO来寻找next类的，不是就是去找父类SomeBaseClass,因为SuperInjector的MRO是自身&gt; UnsuperChild &gt; InjectMe &gt; SomeBaseClass &gt; object 还有就是 super 不是在SuperChild内么，为什么要按SuperInjector的MRO来？？这里应该是因为SuperInjector的init没有定义，然后是用的supserchild的，但是还是按照自身的MRO来。怎么做实验 ) 结论一直使用super来引用父类就好了 你想要引用的父类是MRO下一个类，而不是你看到的继承的关系 不使用super 回让你代码的使用者多了很多不必要的限制 我的：一个例子就是123456from collections imoprt Counter, OrderedDictclass OrderedCounter(Counter, OrderedDict): passoc = OrderedCounter("abracadabra") 之前还一直奇怪这个为什么类里面pass，什么都不用写就能结合，现在知道是因为有super相当于我先把参数传递到Counter初始化，然后因为有super找到的是下一个MRO，然后到OrderedDict初始化相当于两个工序，先count再order。 How does Python’s super() actually work, in the general case?现在有很多有关super()的资源，包括这个博客写的，还有很多stackoverflow上的问题。但是我感觉它们都没有解释它在普遍情况下是怎么工作的，也就是底层的实现。 考虑下面的这个继承层次： 123456789101112131415161718192021class A(object): def foo(self): print 'A foo' class B(A): def foo(self): print 'B foo before' super(B, self).foo() print 'B foo after' class C(A): def foo(self): print 'C foo before' super(C, self).foo() print 'C foo after' class D(B, C): def foo(self): print 'D foo before' super(D, self).foo() print 'D foo after' 如果你读过python的方法解释顺序的规则，你就知道上面的MRO是（D,B,C,A,object)。 这是被D.mro决定的(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;type &#39;object&#39;&gt;)) 和12d = D()d.foo() 打印出的： 1234567D foo beforeB foo beforeC foo beforeA fooC foo afterB foo afterD foo after 结果符合MRO。 但是，考虑上面的B中的super(B,self).foo() 实际调用的是C.foo，这个是在b=B()中；b.foo() 会直接到A.foo 很显然使用super(B,self).foo()不是A.foo(self)的快捷键，虽然有时是 很显然super()是有意识的在意之前的调用，然后尝试着去跟随总的MRO链。我觉得有两个方法能完成这个。第一个是做了一些类似在链中将super对象传递给下一个方法的self参数,像原来self对象那样，但是包含了这个信息，但是这样似乎会破坏很多东西(super(D,d) is d是False)，然后做了一些实验，我觉得这个方法不可行。 另外一个方法是类似全局变量来保存MRO和现在的链上的位置。我想象中的super算法是这样的： 我们当前有工作的环境吗？如果没有，创建一个队列，获取MRO，将除了第一个之外的所有元素入队列 将当前上下文的MRO队列中pop一个元素，在构建super实例的时候将它作为当前的class 当访问super实例的一个方法的时候，在当前class上寻找，然后调用它 但是，这样却没有解释类似使用不一样的基类当作第一个参数来调用super，或者调用不同方法。（这段好别扭）我想知道这个的更普遍的算法。而且，如果这样的context存在的话，我能看吗？我能破坏他么？这当然是一个糟糕的想法，但是python希望你成为一个成熟的人尽管你不是。 这同样也引入了好多设计的考量。如果我写的B只考虑了它和A的联系，然后又有其他人写了C，还有其他人写了D，我的B.foo()方法必须找到一个能兼容C.foo()的方法来调用super，尽管我在写它的时候C不存在。如果我想要我的类能很简单的扩展，那我必须要考虑这些。但是我不清楚这是不是比简单的将所有的foo的特征设置成一样来的更复杂。还有一个问题就是什么时候将代码放在super之前，什么时候之后，即使在仅考虑B的基类的时候它没有什么区别 7票的回答： super() is then obviously aware of the previous calls before it 它不是。当你做super(B,self).foo,super知道你的MRO因为它会从type(self).__mro__中得到。然后它知道应该在MRO的B后面那里开始寻找foo，一个粗略的纯 python写的应该是这样的：12345678910111213141516171819202122232425class super(object): def __init__(self, klass, obj): self.klass = klass self.obj = obj def __getattr__(self, attrname): classes = iter(type(self.obj).__mro__) # search the MRO to find self.klass for klass in classes: if klass is self.klass: break # start searching for attrname at the next class after self.klass for klass in classes: if attrname in klass.__dict__: attr = klass.__dict__[attrname] break else: raise AttributeError # handle methods and other descriptors try: return attr.__get__(self.obj, type(self.obj)) except AttributeError: return attr If I wrote B thinking only of its relation to A, then later someone else writes C and a third person writes D, my B.foo() method has to call super in a way that is compatible with C.foo() even though it didn’t exist at the time I wrote it! 并不要求你要从随机的类中多种继承。除非foo是被特意设计成在多重继承的时候将兄弟类的重写。D不应该存在。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[understanding MRO]]></title>
      <url>%2F2017%2F03%2F13%2Fmro%2F</url>
      <content type="text"><![CDATA[其实我一直觉得遇到什么障碍再去学什么是效率比较高的，这时候是带着问题去解决问题，比起干看，没有与实际相结合，要有用多了。所以等你真正遇到这个问题了，再来看看。 这个MRO是理解super方法的前序 ,以下考虑的都是多重继承，单重继承讨论这个就没什么价值了。 Method Resolution Order In computing, the C3 superclass linearization is an algorithm used primarily to obtain the order in which methods should be inherited (the “linearization”) in the presence of multiple inheritance, and is often termed Method Resolution Order (MRO)from wikipedia – C3 linearization 这里引进这个概念。因为在继承中，会有子类继承父类当中的一些元素或方法，但是在多重继承中，到底是哪一个呢？这里就涉及到了MRO，方法解释顺序。可以想像一个列表，里面是继承关系的顺序，当调用子类的方法，或访问子类的元素的时候，就按照这个顺序依次的查找。 12345678class A(object): passclass B(object): passclass C(B): passclass D(A,B,C): pass 你可以试一下，这个D类是定义不了的，会报错12345Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: Error when calling the metaclass bases Cannot create a consistent method resolutionorder (MRO) for bases object, B, C 这里是因为破坏了MRO的一个(monotomic)单调性规定： if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C. 通过C3算法得出的MRO就可以满足上面的这个要求 C3 linearization先定义几个符号表示：C1C2....CN 表示一个[C1,C2,C3….CN]的解决顺序列表，在这样的一个列表中，head是C1，其余的都叫做tail。注意：是从C2到最后都算tail.C+(C1C2...CN) = CC1C2...CN 表示[C] + [C1,C2...CN]L[C]表示linearization of class C，规定L[O] = O,O表示object 算法可以描述为一个递归的过程： the linearization of C is the Sum of C plus the merge of the linearizations of the parents and the list of the parents.L[C(B1B2...BN)] = C + merge(L[B1],...L[BN],B1...BN)顺序很重要，一一对应的。 merge 算法描述为(原文)： take the head of the first list, i.e L[B1][0]; if this head is not in the tail of any of the other lists, then add it to the linearization of C and remove it from the lists in the merge, otherwise look at the head of the next list and take it. if it is a good head, then report the operation until all the class are removed or it is impossible to find good heads. If fail, python will refuse to create the class C and will raise an exception. 没看懂直接看例子。 写出各个的linearization（这个翻译成啥我也不知道）123456L[O] = OL[E] = EOL[D] = DOL[F] = FOL[B] = B + merge(L[D],L[E],DE) = B + merge(DO,EO,DE) 这里是要merge3个list，DO,EO,DE，从第一个DO开始，它的head是D，然后看D是否出现在其他list的tail中中，注意tail是指除了head其余的所有。比如有一个list是ADCBEF,那D出现在第2个位置也算是在tail中，而不是在最后一个位置才算是tail。也就是说只有D出现在其他list首位置的时候，或者就根本没有D，这个D算是一个good head，然后将D加入B的linearization中，如果D不满足上面的条件，那么顺推到下一个list EO中的E，如果再不满足，继续顺推，都不满足的话就raise an exception。 123456L[B] = B + merge(L[D],L[E],DE) = B + merge(DO,EO,DE) = B + D + merge(O,EO,E) #再从第一个list O 开始去第一个元素O，但O不满足，出现在了第二个EO的tail中，顺延 = B + D + E + merge(O,O) = B + D + E + O = BDEO 1234L[C] = C + merge(DO,FO,DF) = C + D + merge(O,FO,F) = C + D + F + merge(O,O) = CDFO 123456789L[A] = A + merge(L[B],L[C],BC) = A + merge(BDEO,CDFO,BC) = A + B + merge(DEO,CDFO,C) = A + B + C + merge(DEO,DFO) = A + B + C + D + merge(EO,FO) = A + B + C + D + E + merge(O,FO) = A + B + C + D + E + F + merge(O,O) = A + B + C + D + E + F + O = ABCDEFO 另一个例子– 不能生成mro 12345L[O] = OL[X] = XOL[Y] = YOL[A] = AXYO L[B] = BYXO #这两个其实也应该通过上面那个merge算法算出来的，只不过这里一眼就能看出来 关键看类C123L[C] = C + merge(AXYO,BYXO,AB) = C + A + merge(XYO,BYXO,B) = C + A + B + merge(XYO,YXO) 到了这里就做不下去了，这里XYO,YXO，不管第一个X还是第二个的Y，都不行！！ X is in the tail of YXO whereas Y is in the tail of XYO因此算法结束.raise an error refuese to create class C 快速判别能否生成MRO的方法以下来自 python Attributes and Methods现在要定义一个新的类class N(A,B,C)画的稍微歪了，第一排全是O，那ok，result中也生成O放在顶部，第二排，BBC，不一样，要全部一样才能放在最后的result中，所以这个是失败的。 如果将类N的定义改为class N(A,C,B) 以上深入了解以下这个机制就可以，在编程的时候可以调用__mro__属性来查看一个类的mro，了解这个更有助于你理解你写的程序，比如super，比如描述符当中也会用到这个概念 出处： The Python 2.3 Method Resolution Order python Attributes and Methods]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python中的对象属性查找]]></title>
      <url>%2F2017%2F03%2F08%2Fobject-attribute-look-up%2F</url>
      <content type="text"><![CDATA[原文链接 这里面已经讲的很详细了。暂时还没有自己的深刻的思考和理解，就先搬运过来。 Instance attribute look up 实例属性查找 The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to getattr() if provided. 现在有一个类C和一个实例c = C()，现在调用c.name，相当于在实例c中查找name属性，流程如下：1234567891011121314151617181920212223Get the Class from InstanceCall the Class&apos;s special method __getattribute__.All objects have a default __getattribute__ Get the Class&apos;s __mro__ as ClassParents For each ClassParent in ClassParents if the Attribute is in the ClassParent&apos;s __dict__ if this attribute is data descriptor return the result from calling the data descriptor&apos;s special method __get__() Breaking the for each(do not continue searching the same Attribute any further) If the Attribute is in Instance&apos;s __dict__ return the value as it is(even if the value is a data descriptor) #这个意思是即使是描述符也直接返回这个对象，不会去调用__get__(),返回值类似&lt;__main__ descriptor object at Ox..&gt; For each ClassParent in ClassParents if the Attribute is in the ClassParent&apos;s __dict__ if is a non-data descriptor return the result from calling the non-data descriptor&apos;s special method __get__() if it is Not a descriptor return the value If Class has the special method __getattr__ return the result from calling the Class&apos;s special method __getattr__ Raise an AttributeError 有几个点要记住！ descriptors are invoked by the getattribute() method overriding getattribute() prevents automatic descriptor calls getattribute() is only available with new style classes and objects object.getattribute() and type.getattribute() make different calls to get() data descriptors always override instance dictionaries. non-data descriptors may be overridden by instance dictionaries. Class attribute look up 类属性的查找一个metaclass M，和一个M的实例，类C，这时候调用C.name的流程：其实和实例访问一一对应，就是各自都升了一个level12345678910111213141516171819202122232425262728Get the MetaClass from ClassCall the Metaclass&apos;s special method __getattribute__ Get the Metaclass&apos;s __mro__ as MetaParents For each MetaParent in MetaParents if the Attribute is in the MetaParent&apos;s __dict__ if is a data descriptor return the result from calling the data descriptor&apos;s special method __get__() Get the Class&apos;s __mro__ as ClassParents For each ClassParent in ClassParents if the Attribute is in the ClassParents&apos;s __dict__ if is a(data or non-data) descriptor return the result from calling the descriptor&apos;s special method __get__() # 实例在这层上不会调用__get__() else return the value For each MetaParent in MetaParents if the Attribute is in the MetaParents&apos;s __dict__ if is a non-data descriptor return the result from calling the non-data descriptor&apos;s special method __get__() if it is NOT a descriptor return the value If MetaClass has the special method __getattr__ return the result from calling the MetaClass&apos;s special method __getattr__ Raises an AttributeError 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#!/usr/bin/env python# coding=utf-8class Desc(object): # 定一个非数据描述符 def __init__(self, msg): self.msg = msg def __get__(self, instance, owner=None): return "&#123;0&#125;: &#123;1&#125;".format(self.typ, self.msg) # self.typ是啥？？？？ class NonDesc(Desc): # non-data descriptor typ = 'NonDesc'class DataDesc(Desc): # data descriptor typ = 'DataDesc' def __set__(self, instance, value): pass def __delete__(self, instance): passclass M(type): x = 'x from M' y = NonDesc('y from cls M') z = DataDesc('z from cls M') def __getattr__(self, name): return "getattr M &#123;0&#125;".format(name)class A(object): #t = 't from A' #u = NonDesc('u from cls A') #v = DataDesc('v from cls A') x = 'x from A' y = NonDesc('y from cls A') z = DataDesc('z from cls A')class B(A): """ metaclass is M """ __metaclass__ = M """ 这个metaclass什么用？？？？ """ class C(B): """ metaclass is inherited from C """ def __getattr__(self, name): return "getattr C: &#123;0&#125;".format(name) c = C()print '******'print 'c.__class__', c.__class__ #其实就是type(c), 还有注意c是新式类，格式应该是&lt;class '__main__.C'&gt;之类的print 'c.__class__.__getattribute__', c.__class__.__getattribute__ # 因为c.__class__也是一个对象# &lt;slot wrapper '__getattribute__' of 'object' objects&gt;print 'c.__class__.__mro__', c.__class__.__mro__ # method resolution order C B A Oprint '******'print 'c.x', c.x """父类们寻找顺序是根据c.__class__.__mro__ 来的c先去寻找父类们中有没有x的描述符，没有，然后在自己的__dict__中找x，也咩有，然后再去父类们的__dict__中找有没有这个属性名的non-data 描述符，没有，不是描述符而是直接属性的呢？A中有，返回A中的x值"""print 'c.y', c.y"""同上，父类的顺序不废话了最终在第三阶段找到A中的y，它是一个non-data descriptor，NonDesc: y from cls A"""print 'c.z', c.z"""在第一个阶段中的A中找到z 是一个data descriptor，饭后 DataDesc: z from cls A"""print 'c.nope', c.nope"""当前三个阶段都找不到的时候，如果类中有定义__getattr__，就到这里去，没有报错这里所有三个阶段没有nope属性，然后到了__getattr__，返回 getattr C: nope"""c.t = 't from obj c'c.u = NonDesc('u from obj c')c.v = DataDesc('v from obj c')c.x = 'x from obj c'c.y = NonDesc('y from obj c')c.z = DataDesc('z from obj c')print '******'print 'c.t', c.t"""如上，在第二个阶段找到t, 返回 t from obj c"""print 'c.u', c.u"""在第二个阶段在c字典里面找到，不管是值还是descriptor ，这里会调用__get__() NonDesc: u from obj cupdate:更正因为在"""print 'c.v', c.v"""在第二阶段c字典里找到, 调用__get__() ，返回 DataDesc: v from obj c"""print 'c.x', c.x"""因为在第一阶段是在类父类中找描述符，虽然A中有属性x但不是描述符，因此进入第二个阶段，在实例字典中找，不管是不是描述符只要名字对了就返回. 这里在这个阶段返回x from obj c"""print 'c.y', c.y"""同上，返回的是 NonDesc: y from obj c"""print 'c.z', c.z"""同上，返回的是 DataDesc: z from obj c"""print '******' # 这里是用到 class attribute look up 。 以上是对实例进行点运算print "C.x", C.x"""因为B的metaclass是M了，C继承B，C现在的metaclass也是M现在要将上面的所有概念都升级，原来class变成metaclass，原来instance变成class先根据metaclass里的mro决定先后顺序metaparents因为这里是类属性访问，C类的metaclass是M，M.__mro__ 是 (&lt;class '__main__.M'&gt;, &lt;type 'type'&gt;, &lt;type 'object'&gt;)按顺序找x的描述符，但M中没有x的描述符，然后type，object都没有。进入第二个阶段，先计算C.__mro__,按照顺序依次访问类字典C,B,A,O ， 如果有属性重名，先要描述符，不然只要是在__dict__中就返回c中没有x,然后去B，B里面也咩有x，到A中，有x但是不是描述符，没关系直接返回,因为也没有名字为x的描述符了。返回x from A"""print "C.y", C.y"""同上，虽然在M中有y但是是非数据描述符，在第2阶段中的A类中找到y非数据描述符,返回 NonDesc: y from cls A"""print "C.z", C.z"""这是在第一个阶段中的M里找到z数据描述符， 返回 DataDesc: z from cls M"""print "C.nope", C.nope"""上面三个阶段都没有，进入第四个阶段，这个阶段不是去C中的__getattr__，因为上面说了都升了一级，现在是在M中的__getattr__，如果M里面没有__getattr__，那么就回报错，现在M有，返回 getattr M nope"""C.t = 't from obj C'C.u = NonDesc('u from obj C')C.v = DataDesc('v from obj C')C.x = 'x from obj C'C.y = NonDesc('y from obj C')C.z = DataDesc('z from obj C')"""如果是类属性访问，好像没有A，B什么事 !!!!写在流程搞错之前，之前在第二阶段没有计算类的__mro__重新看一下流程"""print '******'print "C.t", C.t"""因为metaclass以及mro中都没有t，进入下一个阶段在第二阶段中现在C类中有t这个属性了，返回 t from obj C"""print "C.u", C.u"""同上，在第二阶段中C类的__dict__中找到，返回 NonDesc: u from obj C"""print "C.v", C.v"""同上，在第二阶段中返回 DataDesc: v from obj C"""print "C.x", C.x"""和M中有重名，但是因为M中的不是数据描述符，这个的优先级高，在第二阶段返回 x from obj C虽然A中也有x，但是mro顺序C排在A前面"""print "C.y", C.y"""同上，有重名，但是M中是非数据描述符，第一阶段过，到第二阶段，返回 NonDesc: y from obj C然后A中同理"""print "C.z", C.z"""重名，但是z在M中是数据描述符，在第一阶段就返回 DataDesc: z from cls M"""print "C.nope", C.nope"""这个没有变 getattr M nope""" 结果：1234567891011121314151617181920212223242526272829******c.__class__ &lt;class '__main__.C'&gt;c.__class__.__getattribute__ &lt;slot wrapper '__getattribute__' of 'object' objects&gt;c.__class__.__mro__ (&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)******c.x x from Ac.y NonDesc: y from cls Ac.z DataDesc: z from cls Ac.nope getattr C: nope******c.t t from obj cc.u &lt;__main__.NonDesc object at 0x1009b8f10&gt;c.v &lt;__main__.DataDesc object at 0x1009b8f50&gt;c.x x from obj cc.y &lt;__main__.NonDesc object at 0x1009b8f90&gt;c.z DataDesc: z from cls A******C.x x from AC.y NonDesc: y from cls AC.z DataDesc: z from cls MC.nope getattr M nope******C.t t from obj CC.u NonDesc: u from obj CC.v DataDesc: v from obj CC.x x from obj CC.y NonDesc: y from obj CC.z DataDesc: z from cls MC.nope getattr M nope]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[descriptor]]></title>
      <url>%2F2017%2F03%2F08%2Fdescriptor%2F</url>
      <content type="text"><![CDATA[其实自己没有深入的研究源码，这篇也是基于阅读一些官方文档和他人的博客做的总结。我这里的思路是从描述符的渊源到为什么有这个描述符，然后怎么用这里先直接给出描述符的定义，先有个印象，如果一开始阅读感觉没什么联系，没关系，最终那些点将连成线的。官方的定义： In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are get(), set(), and delete(). If any of those methods are defined for an object, it is said to be a descriptor.from – Descriptor HowTo Guide 也就是只要一个类定义了__get__(),__set__(),__delete__()当中的任意一个特殊方法,这个类就有了个别名“描述符”啦 描述符的由来首先，因为python是一种动态编译的语言，他能在运行中动态添加类属性或类对象属性。那这些属性是被保存在比如a.__dict__这个里面，这里a是一个实例a=A()。其实类也有一个__dict__属性，通过A.__dict__就可以访问到. 123456789101112131415&gt;&gt;&gt; class A(object):... def __init__(self):... self.attr = 1... def foo(self):... print self.attr...&gt;&gt;&gt; a = A()&gt;&gt;&gt; dir(a)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'attr', 'foo']&gt;&gt;&gt; dir(A)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo']&gt;&gt;&gt; a.__dict__&#123;'attr': 1&#125;&gt;&gt;&gt; A.__dict__dict_proxy(&#123;'__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, 'foo': &lt;function foo at 0x101bba668&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bba5f0&gt;&#125;) 注意到在A类中定义了一个foo函数，像这样的函数在C++语言中被称为成员函数，但是可以看到在a.__dict__中没有foo，在A.__dict__中有。其实通过访问，可以看出a.__dict__中保存的都是一些变量属性。这么理解，在C++中成员函数是被所有对象所共享的，不会为没个对象复制一份，这里也一样，可以看作是类的一个属性，不是实例的属性。那其实在python中，这么做是牵涉到了它的另外的两个概念，绑定，未绑定函数和描述符。先说一下，所有的类成员函数都是non-data despriptor。后面会继续解释 In a nutshell, a descriptor is a way to customize what happens when you reference an attribute on a model.from – Python Descriptors, Part 1 of 2 Descriptor are the mechanism behind properties, methods, static methods, class methods and super()from – Descriptor HowTo Guide 访问属性查找属性的访问顺序建议先把下面的看了再来看这个 我之所以说先看下面，又不得不把这个主题先放上来，是因为其实描述符归根结底，目前看到就是对属性的取值赋值操作，只不过是对这个操作封装了一下而已。12a.attr = 1tmp = a.attr 一般的取值赋值就是这样子的，如果attr事先在类里面定义好了的self.attr = arg 上面的a.attr = 1其实就是重新将“标签”a.attr贴到1数值上去，如果没有那就是动态生成attr属性。但是这样的赋值太单一了，什么意思，也就是说，如果我要对赋入的值做下额外的检查，比如学生的成绩，不可能出现负数，身高也不可能出现负数。所以想到了在__init__当中增加一些逻辑代码进行检查123def __init__(self,score): assert score&gt;=0,"value error" self.score = score 但是这样只是在初始化的时候，像a = A(-1)会报错，那之后如果a.score = -100像这样的误操作，也没人阻止。那我们又有了另一种思路123456def get_score(self): return self.scoredef set_score(self,new_score): assert new_score&gt;=0,"value error" self.score = new_score 通过a.set_score(-100)，调用一个函数，并在函数体内进行检查来进行赋值。 总的来讲，python的属性获取，设置，这个属性只是一个存储的地方，只是一个容器，但往往你可能需要更多的功能，比如赋值的时候检验，然后，一般的，是用一些方法来做这些事情，但是如果对于已经存在了的属性，你想用函数代替取值，赋值，你就要重写代码，找到所有用到这些属性的方法，然后改成函数，比如上面的所有a.score = 1像这样的操作改成a.set_score(1)。这样就增加了工作量，这也是为什么在java程序中一个简单的取值都要封装成一个函数，就是为了避免何种情况，常见的模式也就是属性定义为私有变量，然后开放一个公有接口。python中的描述符只不过是另一种方法来实现这种对属性额外控制的需求而已 描述符实例描述符的用法应该不局限于下面给出的例子，要多看其他高人的代码！！！12345678910111213class Positive(object): def __init__(self,name): self.name = name def __get__(self,instance,owner): if instance is None: return self #这里相当于如果通过类调用,Student.score，就返回是类似&lt;descriptor.Positive object at 0x123455..&gt;之类的 return instance.__dict__[self.name] def __set__(self,instance,value): if value &lt; 0: raise ValueError("negative value error...") instance.__dict__[self.name] = value 上面就定义了一个描述符。其实就是一个类，描述符只是个名称而已。在我的世界里，我想叫它皮皮虾都可以。只是全世界就这么流通规定了12345class Student(object): score = Positive('score') #这句话就将score属性让描述符代理了 def __init__(self,name,score): self.name = name self.score = score 现在如果有这么一个语句s = Student(&#39;cy&#39;,100);a = s.score，其实是相当于在做a = type(s).__dict__[&#39;score&#39;].__get__(s,type(s))可以查看Student.__dict__中的score属性是&#39;score&#39;: &lt;__main__.Positive object at 0x101bb8ed0&gt;这样子的。当作了type(s).__dict__[&#39;score&#39;]时其实就是获得了一个实例，之后还可以继续用点运算符往下接着做。 Q&amp;APositive 描述符中的__set__为什么参数中没有类？1234567&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': &lt;__main__.Positive object at 0x101bb8ed0&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;)#注意上面的score属性的值&gt;&gt;&gt; Student.score = 12 # 通过类访问&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': 12, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;)#再对比一下score的值 当类调用的时候，其实就是设置同名新值了，它将原来的描述符给替换覆盖了。 Student类里面的score和self.score,到底用的是哪个？？可以先看一下12345&gt;&gt;&gt; s = Student('cy','100')&gt;&gt;&gt; s.__dict__&#123;'score': '100', 'name': 'cy'&#125;&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': &lt;__main__.Positive object at 0x101bb8ed0&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;) 其实这里涉及到一个优先级的问题，也就是上面的访问属性的顺序链接。这里可以再跳回去看。因为描述符的优先级高！并且会改变默认的get,set方法。 If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has entry with the same name as a non-data descriptor,the dictionary entry takes precedence.from Descriptor HowTo Guide 什么是non-data descriptor后面会说明。 2引申的一个问题就是如果self.score = score没有定义会是什么情况1234567891011121314&gt;&gt;&gt; class Student(object):... score = Positive('score')... def __init__(self,name):... self.name = name...&gt;&gt;&gt; s = Student('cy')&gt;&gt;&gt; s.score = 10&gt;&gt;&gt; s.__dict__&#123;'score': 10, 'name': 'cy'&#125;&gt;&gt;&gt; s.score = -10Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 10, in __set__ValueError: negative error 还是照样行得通。因为instance.__dict__[self.name] = value.虽然初始化的时候没有score这个属性，但其实后面的字典操作，相当于动态增加了这个属性，而且访问的优先级照样根据那个顺序来 如果是self.score = Positive(&#39;score&#39;)会怎么样1234567891011&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... self.score = Positive('score')...&gt;&gt;&gt; s = Student('cy')&gt;&gt;&gt; s.__dict__&#123;'score': &lt;__main__.Positive object at 0x101bc70d0&gt;, 'name': 'cy'&#125;&gt;&gt;&gt; s.score = -10&gt;&gt;&gt; s.__dict__&#123;'score': -10, 'name': 'cy'&#125; 没有起到作用，这是必然的。如果你知道访问顺序了之后，访问s.score时，因为类中没有同名的描述符，所以到实例中的__dict__看，如果有这个key，返回，但这里是赋值操作，参考另一篇python name and values，s.scorei = -10只不过是将score这个name重新贴标签贴到数值-10上去。 __get__中参数owner什么用，也没有用到它啊？后面在classmethod中就会用到这个参数。其实函数参数写在哪里，也不一定都要用到，但更关心为什么要这么设计。后面看看源代码 看一个图： 应用场景python中有个叫修饰器的东西，property()，它是描述符的简介版123456789@propertydef score(self): return self.__score@score.setterdef score(self,score): if score &lt; 0: raise ValueError('negative') self.__score = score calling propery() is a succinct way of building a data descriptor that triggers function calls upon access to an attributefrom Descriptor HowTo Guide 上面的写法@property使用到了装饰器 但是如果一个类里面有很多属性是相同的限制，比如学生的身高不能负数，成绩不能负数，体重不能负数，如果用property的话，那就多了很多重复的代码，每个属性都要像上面一样写一遍。这时候就可以考虑用写一个描述符类来“一统天下”了 在之前说的对于已存在的属性，如果要对它们要进行限制，通过方法的话要找到每一处，这样很不方便，如果使用描述符只需要在类中加上tall = Positive(&#39;tall&#39;)像这样的语句就可以了，而且完全没有任何副作用！！ If looked-up value is an object defining one of the descriptor methods, then python may override the default behavior and invoke the descriptor method instead.from Descriptor HowTo Guide 描述符的种类 学习也要遵循20/80定律，学到的20%就足够写程序了，先跑起来再来完善接下来的80%– 尔东诚霍划夫斯基描述符分data descriptor和non-data descriptor两者之前的区别就是，后者只定义了__get__。也就是没有设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zlt-project]]></title>
      <url>%2F2017%2F03%2F01%2Fzlt-project%2F</url>
      <content type="text"><![CDATA[最近一直在用python写，这个也用python试试。需求图示 用到： 正则表达式：用来匹配test.py中的test名的 shutil模块，shutil.copy复制 os模块，切换目录用的。os.listdir,os.path.isfile等 sys模块，sys.argv命令行参数 Tkinter，图形化界面 主要的拷贝逻辑写出来12345678910111213141516171819import reimport osimport shutilimport syspath_a = sys.argv[1]path_b = sys.argv[2]candidate_list = [x for x in os.listdir(path_b) if os.path.isfile(x) and x[0]!='.']p = re.compile('\w+')candidate = [p.match(file_name).group() for file_name in candidate_list]#先把B文件中的文件名提取出来for prefix in candidate: for every_file in os.listdir(path_a): if predix in every_file: file_path = path_a + '/' + every_file shutil.copy(file_path,path_b) print 'copy %s to %s'%(every_file,path_b) 接下来就是披上一件外衣了，Tkinter。下面是代码 zlt_main_frame_listbox.py 这个是显示文件夹功能的窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/python#-*- coding: utf-8 -*-# File Name: zlt.py# Created Time: Sun Mar 5 21:56:03 2017__author__ = 'Crayon Chaney &lt;mmmmmcclxxvii@gmail.com&gt;'import osfrom Tkinter import *from time import sleepimport pdbclass ShowList(Frame): # count = 0 def __init__(self,parent,initdir=None): # super(ShowList,self).__init__(parent) """ 上面这个为什么不行？？？ """ Frame.__init__(self,parent) self.parent = parent self.cwd = StringVar(self) self.wholecwd = StringVar(self) self.dir_display = Label(self,font = ('Helvetica',12,'bold'),fg = 'blue') self.dir_display.pack() self.dirfm = Frame(self) self.dirsb_y = Scrollbar(self.dirfm) self.dirsb_x = Scrollbar(self.dirfm,orient="horizontal") self.dirlb = Listbox(self.dirfm,yscrollcommand = self.dirsb_y.set,xscrollcommand = self.dirsb_x.set,height =20,width = 30 ) self.dirsb_y.config(command = self.dirlb.yview) self.dirsb_x.config(command = self.dirlb.xview) self.dirlb.bind('&lt;Double-1&gt;',func=self.selectAndGo) self.dirsb_y.pack(side = RIGHT,fill=Y) self.dirsb_x.pack(side = BOTTOM,fill=X) self.dirlb.pack(side=LEFT,fill=BOTH) self.dirfm.pack() self.input = Entry(self,textvariable=self.cwd) self.input.bind('&lt;Return&gt;',func = self.doLs) self.input.pack() self.dirbuttonfm = Frame(self) self.clrbutton = Button(self.dirbuttonfm,text='clear',command=self.clrEntry) self.clrbutton.pack(side=LEFT) self.listbutton = Button(self.dirbuttonfm,text='List Directory',command=self.doLs) self.listbutton.pack(side=LEFT) self.dirbuttonfm.pack() if initdir: self.cwd.set(initdir) self.doLs() def clrEntry(self,ev = None): self.cwd.set('') def selectAndGo(self,ev=None): self.last = self.cwd.get() self.dirlb.config(selectbackground='red') self.cwd.set(self.dirlb.selection_get()) self.doLs() def doLs(self,ev = None): cur = self.cwd.get() error = '' if not os.path.exists(cur): error = '%s is not exists'%cur elif not os.path.isdir(cur): error = "%s is not dir"%cur if error: self.cwd.set(error) self.parent.update() sleep(2) if not (hasattr(self,'last') and self.last): self.last = os.curdir self.cwd.set(self.last) self.dirlb.config(selectbackground='LightSkyBlue') return self.cwd.set('Fetching...') self.parent.update() dirfiles = os.listdir(cur) os.chdir(cur) self.dir_display.config(text=os.getcwd()) self.wholecwd.set(os.getcwd()) dirfiles.sort() self.dirlb.delete(0,END) self.dirlb.insert(END,os.curdir) self.dirlb.insert(END,os.pardir) for eachdirname in dirfiles: self.dirlb.insert(END,eachdirname) self.cwd.set(os.curdir) self.dirlb.config(selectbackground='LightSkyBlue')if __name__ == '__main__': root = Tk() ShowList(root,os.curdir).pack() root.mainloop() zlt_windows.py 主窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/python#-*- coding: utf-8 -*-# File Name: zlt_windows.py# Created Time: Mon Mar 6 14:13:52 2017__author__ = 'Crayon Chaney &lt;mmmmmcclxxvii@gmail.com&gt;'from zlt_main_frame_listbox import *import shutilimport reimport sysclass CopyDir(object): def __init__(self): self.top = Tk() self.top.title('你花大爷呕心沥血作') # ShowList(self.top).pack(side=LEFT) self.A = ShowList(self.top,os.curdir) self.A.pack(side=LEFT) self.topbuttonfm = Frame(self.top) self.copybutton = Button(self.topbuttonfm,text='&lt;--A copy B--&gt;',width = 15,command = self.confirmCopy) self.copybutton.pack() self.quitbutton = Button(self.topbuttonfm,text='退出',command = self.top.quit) self.quitbutton.pack() self.topbuttonfm.pack(side = LEFT,ipadx = 5) # ShowList(self.top).pack(side=LEFT) self.B = ShowList(self.top,os.curdir) self.B.pack(side=LEFT,ipadx = 5) def confirmCopy(self,ev = None): self.confirmtop = Toplevel(self.top) # pdb.set_trace() self.a_path = self.A.wholecwd.get() self.b_path = self.B.wholecwd.get() listfiles_a = os.listdir(self.a_path) listfiles_b = os.listdir(self.b_path) title_msg = '复制这些到%s'%self.b_path self.confirmtop.title(title_msg) # self.fm = Frame(self.confirmtop) # to be pack self.copy_candidates_info = Text(self.confirmtop,height=30,width = 20) # to be pack pattern = re.compile('\w+') self.to_be_copied_list = [] for to_be_copied in listfiles_b: try: prefix = pattern.match(to_be_copied).group() except AttributeError,e: continue # print e # if 'NoneType' in e: # continue # else: # sys.exit() for eachfile in listfiles_a: if prefix in eachfile :# and os.path.isfile(self.a_path+'/'+prefix): 可能在windows下不支持 self.to_be_copied_list.append(eachfile) # self.copy_candidates_info.delete(0,END) for item in self.to_be_copied_list: self.copy_candidates_info.insert(END,item+'\n') # window下换行符可能不一样 \r\n self.copy_candidates_info.pack(side = LEFT,padx = 10) information = 'copy to %s'%self.b_path self.other_information = Label(self.confirmtop,text = information) self.other_information.pack(side=LEFT,ipadx = 5,ipady = 13) self.fm = Frame(self.confirmtop) self.result_info = Label(self.fm,font = ('Helvetica',12,'bold'),fg='red') self.confirmbutton = Button(self.fm,text='确认',command = self.copyExecute) self.cancelbutton = Button(self.fm,text='取消',command = self.confirmtop.quit) """ 为什么点击取消会全体退出？？？ 想要的效果是只是这个确认窗口退出而已 """ self.result_info.pack(side=LEFT) self.confirmbutton.pack(side = LEFT) self.cancelbutton.pack(side=LEFT) self.fm.pack(side = BOTTOM) def copyExecute(self,ev=None): os.chdir(self.a_path) if not (hasattr(self,'to_be_copied_list') and len(self.to_be_copied_list)): self.result_info.config(text='Failed') return for item in self.to_be_copied_list: try: shutil.copy(item,self.b_path) except Exception,e: self.result_info.config(text=e) else: self.result_info.config(text='Successful') def main(): c = CopyDir() mainloop()if __name__ == '__main__': main() 发现的bug： 因为我现在是在一个窗口生成了两个文件夹展示的frame，但是在一个进程中，一个文件夹切换了路径，另一个就跟着切换了导致出现bug，解决方法，要用多线程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python types and objects]]></title>
      <url>%2F2016%2F12%2F03%2Fpython-types-and-objects%2F</url>
      <content type="text"><![CDATA[Python Types and Objects这篇文章解释了： 什么是&lt;type &#39;type&#39;&gt;和 用户自定义的类和实例是怎么联系在一起的以及和内建类型的联系 什么是metaclass元类 type和object从之前的学习面向对象编程来看，我们可以通过继承来定义一个类，也可以查看一个对象属于哪个类。其实这就可以抽象出两种关系图中虚线就是type，表示一个对象(又称‘实例’)的类型是尖头指向的那个图中的实线是base，表示一个类的基类是尖头指向的那个 the type and base(if exist) are important, coz they define special relationships an object with other objects. 因为在python中一切皆为对象，所以base到头了就是object，这个是在python中一切类的祖宗。而因为python中一切皆为对象, 它就有类型，object也是一个对象，它的类型就是type，type本身也是一个对象，为了满足python这样的设定，它的类型就是它自己。type既是一个对象，也是一个类。就说我们自己定义了一个类1234567&gt;&gt;&gt; class A(object):... pass...&gt;&gt;&gt; A.__bases__(&lt;type 'object'&gt;,)&gt;&gt;&gt; A.__class__&lt;type 'type'&gt; 他也有类型，就是type类型 keep in mind that the types and bases of objects just other objects 既然像类也是一种”对象”,那它是谁的对象？？答案就是metaclass，type就是metaclass。先有鸡还是先有蛋？ 类和类型的统一这个问题在知乎上有一个解答不错 旧式类的实现不够好，类是类，实例是实例，类的类型是classobj，实例的类型是instance，两者的联系只在于class，这和内置对象是不同的，int对象的类型就是int，同时int()返回的也是int类型的对象，内置对象和自定义对象不同就对代码统一实现带来很大困难。比如说有段代码输入一个对象，返回一个默认构造的同类型对象，本来应该写作type(obj)()，现在就必须写成：obj.class() if hasattr(obj, ‘class‘) else type(obj)()。如果想用自定义的类去替代一些系统内置类型，比如说自定义一个dictionary，这样的不一致就会出问题新式类之后自定义类和内置类型就一致了：1. 所有类型的类型都是type2. 所有类型调用的结果都是构造，返回这个类型的实例3. 所有类型都是object的子类这样就不再需要区分自定义类和类型了。实现这件事其实并不容易，理性上来想，type的基类是object，而object的类型是type，这是一个先有鸡还是先有蛋的问题。Python通过对这几个类的特殊处理实现了这样的逻辑。 作者：灵剑链接：https://www.zhihu.com/question/38803693/answer/103128686来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 自定义类和内建类型图片来自那个文章顶部那个链接,这篇文章写的很详细了 Dashed lines cross spacial boundaries (i.e. go from object to meta-object). Only exception is (which is good, otherwise we would need another space to the left of it, and another, and another…). Solid lines do not cross space boundaries. Again, -&gt; is an exception. Solid lines are not allowed in the rightmost space. These objects are too concrete to be subclassed. Dashed line arrow heads are not allowed rightmost space. These objects are too concrete to be instantiated. Left two spaces contain types. Rightmost space contains non-types. If we created a new object by subclassing it would be in the leftmost space, and would also be both a subclass and instance of . 两个对象python中分Type对象和Non-Type对象，这个Non-Type不是一个正式的概念，只是这么称呼，这类对象，比如2，就是2，2怎么再派生？怎么再实例化，不行，所以是too concrete。怎么判断，只要type(obj)出来的是&lt;type &#39;type&#39;&gt;就是Type对象，不然就是Non-Type对象 Type objects - can create instances, can be subclassed. Non-type objects - cannot create instances, cannot be subclassed. objectname.__class__ exists for every object and points the type of the object. objectname.__bases__ exists for every type object and points the superclasses of the object. It is empty only for &lt;type &#39;object&#39;&gt;. Some non-type objects can be created using special Python syntax. For example, [1, 2, 3] creates an instance of &lt;type &#39;list&#39;&gt;. 两个动作两种关系对应两种动作可以生成两种对象。有可能是Type对象,也有可能是Non-Type对象。两个动作就是subclassing和instantiating. subclassing这个动作具体就是class语句,定义一个类，或者说定一个type， This means you can create a new object that is somewhat similar to existing type objects. To create a new object using subclassing, we use the class statement and specify the bases (and, optionally, the type) of the new object. This always creates a type object. 这段代码抽象代表的就是一个类 instantiating这个动作就是实例化，由一个type实例化出对象，type相当于一个工厂的模型，具体就是通过()操作。 To create a new object using instantiation, we use the call operator (()) on the type object we want to use. This may create a type or a non-type object, depending on which type object was used. This means you can create a new object that is an instance of the existing type object. python中的内建类型是在启动python后生成的。比如1234567&gt;&gt;&gt; type(list)&lt;type 'type'&gt;&gt;&gt;&gt; list.__bases__(&lt;type 'object'&gt;,) # list是从object派生而来了&gt;&gt;&gt; ml = [1,2,3]&gt;&gt;&gt; type(ml)&lt;type 'list'&gt; 如果问[1,2,3]是什么类型啊？列表类型啊。列表类型是什么类型啊？type类型啊。type类型是什么类型啊？type类型。。。当我们创建{‘a’:1,’b’:2},(1,2)这种，是从&lt;type &#39;list&#39;&gt;,&lt;type &#39;dict&#39;&gt;实例化出来的，也就是相应的type，包括自定义。 metaclass很重要的一点就是，当我class语句定义了一个类，我就自动的有了一个type，其实也就是说__class__（新式类）12class C(object): pass type(C)就已经定了。它是根据所继承的父类的type延续下来的，因为object的类型是type所以12&gt;&gt;&gt;type(C)&lt;type 'type'&gt; 那其实这样追溯下去，因为object类型是type类，所以所有的类都是type类。除了Non-Type对象的类型是相对应的类。所以那幅图的前面两列的虚线都指到type。这里有一个问题就是它是由继承关系决定的，那如果是多重继承呢？是继承哪个？1234567891011121314151617181920212223&gt;&gt;&gt; class M1(type):... pass...&gt;&gt;&gt; class M2(type):... pass...&gt;&gt;&gt; class A(object):... __metaclass__ = M1...&gt;&gt;&gt; class B(object):... __metaclass__ = M2...&gt;&gt;&gt; type(A)&lt;class '__main__.M1'&gt;&gt;&gt;&gt; type(B)&lt;class '__main__.M2'&gt;&gt;&gt;&gt; class C(A,B):... pass...Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: Error when calling the metaclass bases metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases 如果大家的metaclass都一样，那就没得说了，如果不一样，那么就会混乱，这时候要指定。什么时候会不一样呢？一般情况下都是type，除非自己定义specialType然后派生。但建议是不要用这个特性。 另一个问题就是，到底怎么自定义specialType？上面例子已经给出答案了。12class C(object): __metaclass__ = specialType 隐式关系图片来自文章顶部链接文章中的： issubclass问的是一个class是不是subclass of 另一个class。class和class之间的关系isinstance问的是一个object是不是instance of 另一个class。object和class之间的关系 12345678910111213141516&gt;&gt;&gt; isinstance(type,type) #虚线，type指向自己 True&gt;&gt;&gt; isinstance(type,object) #因为type是自身的实例，type又是object的子类，所以type是object的实例True&gt;&gt;&gt; isinstance(object,object) #因为object是type的实例，type又是object的子类，所以object是object的实例True&gt;&gt;&gt; isinstance(object,type) # 虚线True&gt;&gt;&gt; issubclass(type,type) # A class is considered a subclass of itselfTrue&gt;&gt;&gt; issubclass(type,object) # 实线True&gt;&gt;&gt; issubclass(object,object) # 任何类都是object的子类True&gt;&gt;&gt; issubclass(object,type) # object在类的金字塔顶端，它上面就没人啦False A class is considered a subclass of itself Q&amp;A class,object,instance的关系 An object is an instance of a class, and may be called a class instance or class object; instantiation is then also known as construction. Not all classes can be instantiated – abstract classes cannot be instantiated, while classes that can be instantiated are called concrete classes. How does python really create a new object? Internally, when python creates a new object, it always uses a type and creates an instance of that object. Specifically it uses the new() and init() methods of the type. In a sense, the type serves as a factory that can churn out new objects, the type of these manufactured objects will be the type object used to create them. This is why every object has a type.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Interesting experience -- challenge school master swimming]]></title>
      <url>%2F2016%2F11%2F11%2Fswimming-with-master%2F</url>
      <content type="text"><![CDATA[–update–其实现在想想，可能当初会有更成熟的做法。 我写在了公号里。MMMMMCCLXXVII]]></content>
    </entry>

    
  
  
</search>
