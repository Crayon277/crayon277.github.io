<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python name and values]]></title>
      <url>%2F2017%2F03%2F29%2Fpython-name-and-values%2F</url>
      <content type="text"><![CDATA[阅读 Facts and myths about Python names and values 做的摘记内容不是很深，只是这里面提到了一些需要注意的点。最主要还是name和value的区别 Fact: Names have no type, values have no scope. Just as names have no type, values have no scope. When we say that a function has a local variable, we mean that the name is scoped to the function: you can’t use the name outside the function, and when the function returns, the name is destroyed. But as we’ve seen, if the name’s value has other references, it will live on beyond the function call. It is a local name, not a local value. 翻译： 就跟名字没有类型一样，数值是没有作用范围的。当我们说一个函数有局部变量的时候，我们只是说的是名字只在函数作用域中起作用而已，你不能在函数外使用这个名字，当函数返回的时候，这个名字也就摧毁了。但是，如果这个名字指向的数值还有其他引用，它就会继续生存下去，不管这个函数了。局部变量，而不是局部数值。 Fact: Values can’t be deleted, only names can. Python’s memory management is so central to its behavior, not only do you not have to delete values, but there is no way to delete values. You may have seen the del statement: 12nums = [1, 2, 3]del nums This does not delete the value nums, it deletes the name nums. The name is removed from its scope, and then the usual reference counting kicks in: if nums’ value had only that one reference, then the value will be reclaimed. But if it had other references, then it will not. Fact: Assignment never copies data. Mutable means that the value has methods that can change the value in-place. Immutable means that the value can never change, instead when you think you are changing the value, you are really making new values from old ones. 比如：12x = 3y = x x和y只是一起指向了3而已，并没有给y再来一个3。这里x,y是name，3是value上面说到的Mutable是什么意思，也就是因为这个赋值不拷贝数据的特性，当y变了的时候，比如y+=1，那x还变不变？这里就要考虑到可变类型和不可变类型了 Immutable values: numbers strings tuples Mutable values: lists dicts user-defined objects 那在上面y+=1之后，其实是给y重新reference到了4 关于mutable的直接截图： Fact: Python passes function arguments by assigning to them.123def my_func(x,y) return x+yprint(my_func(8,9)) The names x and y are local to the function, so when the function returns, those names go away. But if the values they refer to are still referenced by other names, the values live on. 注意，这里就出现name和value的区别了，可以这样理解，value就是一个实物，name只是这个实物的标签，我可以贴很多标签，而看到这个标签，我就联想到这个实物，实物可以有多个标签，一个标签只能对应一个实物。 1234567def augment_twice(a_list,val): a_list.append(val) a_list.append(val)nums = [1,2,3]augment_twice(nums, 4)print(nums) #[1,2,3,4,4] 虚线框表示本地name在一个新的frame里面，而参数传递只是一种赋值操作，a_list “指向” nums指向的value,而list类型是可变数据类型，所以任何name对它的改变都是就地的，可以通过id()操作来查看是否改变了地址 另外一个程序 12345def augment_twice_bad(a_list,val): a_list = a_list + [val,val]nums = [1,2,3]augment_twice_bad(nums,4)print(nums) #[1,2,3] 这个跟上面的程序就不同在函数里面一个是用.append()来增加元素，一个则用加法然后赋值，赋值，赋值，重要的事情说三遍，这是个赋值操作，一旦出现赋值，就相当于等式左边的namerebind出现在等式右边的value It’s really important to keep in mind the difference between mutating a value in place, and rebinding a name. augment_twice worked because it mutated the value passed in, so that mutation was available after the function returned. augment_twice_bad used an assignment to rebind a local name, so the changes weren’t visible outside the function. 其他的 facts, myths都知道了，上面的需要注意一下就可以了。过]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[project of stackoverflow - python object(一)]]></title>
      <url>%2F2017%2F03%2F14%2Fobject%2F</url>
      <content type="text"><![CDATA[what does ‘super’ do in python下面两个的区别是？ 123class Child(SomeBaseClass): def __init__(self): super(Child, self).__init__() 和123class Child(SomeBaseClass): def __init__(self): SomeBaseClass.__init__(self) 我在单个继承中已经看到super 被用的很多了。我能知道为什么要在多重继承的时候用它，但是还是不清楚在这种情况用它的好处。 180票的回答：（John Millikin) 在单一继承用super的好处很小–只是你不再需要硬编码基类名字到方法里面去了 然后，在多重继承里，不用super()几乎是不可能的。这包括常见的习语，像是mixins，interface,abstract classes等，这能让你的代码在之后延伸。如果以后有人想写一个拓展Child 和 mixin的类，他们的代码不会很好的工作。 75票的回答： 区别是什么？ SomeBaseClass.__init__(self)意思是调用SomeBaseClass的__init__方法然后，super(Child,self).__init__()意思是从Child类的MRO的父类中调用一个绑定方法__init__如果实例是Child的子类，有可能在方法解释顺序中的下一个父类是不一样的？？？ 向前兼容间接 ？？ （Indirection with Forward Compatibility) 这能给你什么？对于单重继承，问题中给出的例子几乎等同于静态分析。然而使用super 提供了具有向前兼容性的间接层向前兼容对于经验丰富的开发者来说是很重要的。你希望你的代码在做出一些细微的改动之后还能工作。当您查看修订历史记录时，您希望准确地查看何时更改了哪些内容。 你可能先从单重继承开始，但是当你增加另外的基类，你只需要改变基类的顺序（change the line with the bases）（if the bases change in a class you inherit from）如果类继承关系变了（比如增加了一个mixin)，其实你就没做什么改变。尤其在python2中，要想给super正确的方法参数是很难的。如果你知道你在单重继承下正确的使用super，这样是的调试就容易一点了 依赖注入 Dependency Injection 其他人可以使用你的代码然后插入一些父类到方法解释中(method resolution): 12345678910111213class SomeBaseClass(object): def __init__(self): print('SomeBaseClass.__init__(self) called') class UnsuperChild(SomeBaseClass): def __init__(self): print('UnsuperChild.__init__(self) called') SomeBaseClass.__init__(self) class SuperChild(SomeBaseClass): def __init__(self): print('SuperChild.__init__(self) called') super(SuperChild, self).__init__() 现在你增加其他类，然后在Foo和Bar之间插入一个类 12345678class InjectMe(SomeBaseClass): def __init__(self): print('InjectMe.__init__(self) called') super(InjectMe, self).__init__() class UnsuperInjector(UnsuperChild, InjectMe): pass class SuperInjector(SuperChild, InjectMe): pass 使用un-super子类未能注入依赖，因为你是用的子类在自己执行打印后调用的是硬编码方法 123&gt;&gt;&gt; o = UnsuperInjector()UnsuperChild.__init__(self) calledSomeBaseClass.__init__(self) called 然而使用super的子类能正确的依赖注入 1234&gt;&gt;&gt; o2 = SuperInjector()SuperChild.__init__(self) calledInjectMe.__init__(self) calledSomeBaseClass.__init__(self) called (我：因为super按照MRO来寻找next类的，不是就是去找父类SomeBaseClass,因为SuperInjector的MRO是自身&gt; UnsuperChild &gt; InjectMe &gt; SomeBaseClass &gt; object 还有就是 super 不是在SuperChild内么，为什么要按SuperInjector的MRO来？？这里应该是因为SuperInjector的init没有定义，然后是用的supserchild的，但是还是按照自身的MRO来。怎么做实验 ) 结论一直使用super来引用父类就好了 你想要引用的父类是MRO下一个类，而不是你看到的继承的关系 不使用super 回让你代码的使用者多了很多不必要的限制 我的：一个例子就是123456from collections imoprt Counter, OrderedDictclass OrderedCounter(Counter, OrderedDict): passoc = OrderedCounter("abracadabra") 之前还一直奇怪这个为什么类里面pass，什么都不用写就能结合，现在知道是因为有super相当于我先把参数传递到Counter初始化，然后因为有super找到的是下一个MRO，然后到OrderedDict初始化相当于两个工序，先count再order。 How does Python’s super() actually work, in the general case?现在有很多有关super()的资源，包括这个博客写的，还有很多stackoverflow上的问题。但是我感觉它们都没有解释它在普遍情况下是怎么工作的，也就是底层的实现。 考虑下面的这个继承层次： 123456789101112131415161718192021class A(object): def foo(self): print 'A foo' class B(A): def foo(self): print 'B foo before' super(B, self).foo() print 'B foo after' class C(A): def foo(self): print 'C foo before' super(C, self).foo() print 'C foo after' class D(B, C): def foo(self): print 'D foo before' super(D, self).foo() print 'D foo after' 如果你读过python的方法解释顺序的规则，你就知道上面的MRO是（D,B,C,A,object)。 这是被D.mro决定的(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;type &#39;object&#39;&gt;)) 和12d = D()d.foo() 打印出的： 1234567D foo beforeB foo beforeC foo beforeA fooC foo afterB foo afterD foo after 结果符合MRO。 但是，考虑上面的B中的super(B,self).foo() 实际调用的是C.foo，这个是在b=B()中；b.foo() 会直接到A.foo 很显然使用super(B,self).foo()不是A.foo(self)的快捷键，虽然有时是 很显然super()是有意识的在意之前的调用，然后尝试着去跟随总的MRO链。我觉得有两个方法能完成这个。第一个是做了一些类似在链中将super对象传递给下一个方法的self参数,像原来self对象那样，但是包含了这个信息，但是这样似乎会破坏很多东西(super(D,d) is d是False)，然后做了一些实验，我觉得这个方法不可行。 另外一个方法是类似全局变量来保存MRO和现在的链上的位置。我想象中的super算法是这样的： 我们当前有工作的环境吗？如果没有，创建一个队列，获取MRO，将除了第一个之外的所有元素入队列 将当前上下文的MRO队列中pop一个元素，在构建super实例的时候将它作为当前的class 当访问super实例的一个方法的时候，在当前class上寻找，然后调用它 但是，这样却没有解释类似使用不一样的基类当作第一个参数来调用super，或者调用不同方法。（这段好别扭）我想知道这个的更普遍的算法。而且，如果这样的context存在的话，我能看吗？我能破坏他么？这当然是一个糟糕的想法，但是python希望你成为一个成熟的人尽管你不是。 这同样也引入了好多设计的考量。如果我写的B只考虑了它和A的联系，然后又有其他人写了C，还有其他人写了D，我的B.foo()方法必须找到一个能兼容C.foo()的方法来调用super，尽管我在写它的时候C不存在。如果我想要我的类能很简单的扩展，那我必须要考虑这些。但是我不清楚这是不是比简单的将所有的foo的特征设置成一样来的更复杂。还有一个问题就是什么时候将代码放在super之前，什么时候之后，即使在仅考虑B的基类的时候它没有什么区别 7票的回答： super() is then obviously aware of the previous calls before it 它不是。当你做super(B,self).foo,super知道你的MRO因为它会从type(self).__mro__中得到。然后它知道应该在MRO的B后面那里开始寻找foo，一个粗略的纯 python写的应该是这样的：12345678910111213141516171819202122232425class super(object): def __init__(self, klass, obj): self.klass = klass self.obj = obj def __getattr__(self, attrname): classes = iter(type(self.obj).__mro__) # search the MRO to find self.klass for klass in classes: if klass is self.klass: break # start searching for attrname at the next class after self.klass for klass in classes: if attrname in klass.__dict__: attr = klass.__dict__[attrname] break else: raise AttributeError # handle methods and other descriptors try: return attr.__get__(self.obj, type(self.obj)) except AttributeError: return attr If I wrote B thinking only of its relation to A, then later someone else writes C and a third person writes D, my B.foo() method has to call super in a way that is compatible with C.foo() even though it didn’t exist at the time I wrote it! 并不要求你要从随机的类中多种继承。除非foo是被特意设计成在多重继承的时候将兄弟类的重写。D不应该存在。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[understanding MRO]]></title>
      <url>%2F2017%2F03%2F13%2Fmro%2F</url>
      <content type="text"><![CDATA[其实我一直觉得遇到什么障碍再去学什么是效率比较高的，这时候是带着问题去解决问题，比起干看，没有与实际相结合，要有用多了。所以等你真正遇到这个问题了，再来看看。 这个MRO是理解super方法的前序 ,以下考虑的都是多重继承，单重继承讨论这个就没什么价值了。 Method Resolution Order In computing, the C3 superclass linearization is an algorithm used primarily to obtain the order in which methods should be inherited (the “linearization”) in the presence of multiple inheritance, and is often termed Method Resolution Order (MRO)from wikipedia – C3 linearization 这里引进这个概念。因为在继承中，会有子类继承父类当中的一些元素或方法，但是在多重继承中，到底是哪一个呢？这里就涉及到了MRO，方法解释顺序。可以想像一个列表，里面是继承关系的顺序，当调用子类的方法，或访问子类的元素的时候，就按照这个顺序依次的查找。 12345678class A(object): passclass B(object): passclass C(B): passclass D(A,B,C): pass 你可以试一下，这个D类是定义不了的，会报错12345Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: Error when calling the metaclass bases Cannot create a consistent method resolutionorder (MRO) for bases object, B, C 这里是因为破坏了MRO的一个(monotomic)单调性规定： if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C. 通过C3算法得出的MRO就可以满足上面的这个要求 C3 linearization先定义几个符号表示：C1C2....CN 表示一个[C1,C2,C3….CN]的解决顺序列表，在这样的一个列表中，head是C1，其余的都叫做tail。注意：是从C2到最后都算tail.C+(C1C2...CN) = CC1C2...CN 表示[C] + [C1,C2...CN]L[C]表示linearization of class C，规定L[O] = O,O表示object 算法可以描述为一个递归的过程： the linearization of C is the Sum of C plus the merge of the linearizations of the parents and the list of the parents.L[C(B1B2...BN)] = C + merge(L[B1],...L[BN],B1...BN)顺序很重要，一一对应的。 merge 算法描述为(原文)： take the head of the first list, i.e L[B1][0]; if this head is not in the tail of any of the other lists, then add it to the linearization of C and remove it from the lists in the merge, otherwise look at the head of the next list and take it. if it is a good head, then report the operation until all the class are removed or it is impossible to find good heads. If fail, python will refuse to create the class C and will raise an exception. 没看懂直接看例子。 写出各个的linearization（这个翻译成啥我也不知道）123456L[O] = OL[E] = EOL[D] = DOL[F] = FOL[B] = B + merge(L[D],L[E],DE) = B + merge(DO,EO,DE) 这里是要merge3个list，DO,EO,DE，从第一个DO开始，它的head是D，然后看D是否出现在其他list的tail中中，注意tail是指除了head其余的所有。比如有一个list是ADCBEF,那D出现在第2个位置也算是在tail中，而不是在最后一个位置才算是tail。也就是说只有D出现在其他list首位置的时候，或者就根本没有D，这个D算是一个good head，然后将D加入B的linearization中，如果D不满足上面的条件，那么顺推到下一个list EO中的E，如果再不满足，继续顺推，都不满足的话就raise an exception。 123456L[B] = B + merge(L[D],L[E],DE) = B + merge(DO,EO,DE) = B + D + merge(O,EO,E) #再从第一个list O 开始去第一个元素O，但O不满足，出现在了第二个EO的tail中，顺延 = B + D + E + merge(O,O) = B + D + E + O = BDEO 1234L[C] = C + merge(DO,FO,DF) = C + D + merge(O,FO,F) = C + D + F + merge(O,O) = CDFO 123456789L[A] = A + merge(L[B],L[C],BC) = A + merge(BDEO,CDFO,BC) = A + B + merge(DEO,CDFO,C) = A + B + C + merge(DEO,DFO) = A + B + C + D + merge(EO,FO) = A + B + C + D + E + merge(O,FO) = A + B + C + D + E + F + merge(O,O) = A + B + C + D + E + F + O = ABCDEFO 另一个例子– 不能生成mro 12345L[O] = OL[X] = XOL[Y] = YOL[A] = AXYO L[B] = BYXO #这两个其实也应该通过上面那个merge算法算出来的，只不过这里一眼就能看出来 关键看类C123L[C] = C + merge(AXYO,BYXO,AB) = C + A + merge(XYO,BYXO,B) = C + A + B + merge(XYO,YXO) 到了这里就做不下去了，这里XYO,YXO，不管第一个X还是第二个的Y，都不行！！ X is in the tail of YXO whereas Y is in the tail of XYO因此算法结束.raise an error refuese to create class C 快速判别能否生成MRO的方法以下来自 python Attributes and Methods现在要定义一个新的类class N(A,B,C)画的稍微歪了，第一排全是O，那ok，result中也生成O放在顶部，第二排，BBC，不一样，要全部一样才能放在最后的result中，所以这个是失败的。 如果将类N的定义改为class N(A,C,B) 以上深入了解以下这个机制就可以，在编程的时候可以调用__mro__属性来查看一个类的mro，了解这个更有助于你理解你写的程序，比如super，比如描述符当中也会用到这个概念 出处： The Python 2.3 Method Resolution Order python Attributes and Methods]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python中的对象属性查找]]></title>
      <url>%2F2017%2F03%2F08%2Fobject-attribute-look-up%2F</url>
      <content type="text"><![CDATA[原文链接 这里面已经讲的很详细了。暂时还没有自己的深刻的思考和理解，就先搬运过来。 Instance attribute look up 实例属性查找 The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to getattr() if provided. 现在有一个类C和一个实例c = C()，现在调用c.name，相当于在实例c中查找name属性，流程如下：1234567891011121314151617181920212223Get the Class from InstanceCall the Class&apos;s special method __getattribute__.All objects have a default __getattribute__ Get the Class&apos;s __mro__ as ClassParents For each ClassParent in ClassParents if the Attribute is in the ClassParent&apos;s __dict__ if this attribute is data descriptor return the result from calling the data descriptor&apos;s special method __get__() Breaking the for each(do not continue searching the same Attribute any further) If the Attribute is in Instance&apos;s __dict__ return the value as it is(even if the value is a data descriptor) #这个意思是即使是描述符也直接返回这个对象，不会去调用__get__(),返回值类似&lt;__main__ descriptor object at Ox..&gt; For each ClassParent in ClassParents if the Attribute is in the ClassParent&apos;s __dict__ if is a non-data descriptor return the result from calling the non-data descriptor&apos;s special method __get__() if it is Not a descriptor return the value If Class has the special method __getattr__ return the result from calling the Class&apos;s special method __getattr__ Raise an AttributeError 有几个点要记住！ descriptors are invoked by the getattribute() method overriding getattribute() prevents automatic descriptor calls getattribute() is only available with new style classes and objects object.getattribute() and type.getattribute() make different calls to get() data descriptors always override instance dictionaries. non-data descriptors may be overridden by instance dictionaries. Class attribute look up 类属性的查找一个metaclass M，和一个M的实例，类C，这时候调用C.name的流程：其实和实例访问一一对应，就是各自都升了一个level12345678910111213141516171819202122232425262728Get the MetaClass from ClassCall the Metaclass&apos;s special method __getattribute__ Get the Metaclass&apos;s __mro__ as MetaParents For each MetaParent in MetaParents if the Attribute is in the MetaParent&apos;s __dict__ if is a data descriptor return the result from calling the data descriptor&apos;s special method __get__() Get the Class&apos;s __mro__ as ClassParents For each ClassParent in ClassParents if the Attribute is in the ClassParents&apos;s __dict__ if is a(data or non-data) descriptor return the result from calling the descriptor&apos;s special method __get__() # 实例在这层上不会调用__get__() else return the value For each MetaParent in MetaParents if the Attribute is in the MetaParents&apos;s __dict__ if is a non-data descriptor return the result from calling the non-data descriptor&apos;s special method __get__() if it is NOT a descriptor return the value If MetaClass has the special method __getattr__ return the result from calling the MetaClass&apos;s special method __getattr__ Raises an AttributeError 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#!/usr/bin/env python# coding=utf-8class Desc(object): # 定一个非数据描述符 def __init__(self, msg): self.msg = msg def __get__(self, instance, owner=None): return "&#123;0&#125;: &#123;1&#125;".format(self.typ, self.msg) # self.typ是啥？？？？ class NonDesc(Desc): # non-data descriptor typ = 'NonDesc'class DataDesc(Desc): # data descriptor typ = 'DataDesc' def __set__(self, instance, value): pass def __delete__(self, instance): passclass M(type): x = 'x from M' y = NonDesc('y from cls M') z = DataDesc('z from cls M') def __getattr__(self, name): return "getattr M &#123;0&#125;".format(name)class A(object): #t = 't from A' #u = NonDesc('u from cls A') #v = DataDesc('v from cls A') x = 'x from A' y = NonDesc('y from cls A') z = DataDesc('z from cls A')class B(A): """ metaclass is M """ __metaclass__ = M """ 这个metaclass什么用？？？？ """ class C(B): """ metaclass is inherited from C """ def __getattr__(self, name): return "getattr C: &#123;0&#125;".format(name) c = C()print '******'print 'c.__class__', c.__class__ #其实就是type(c), 还有注意c是新式类，格式应该是&lt;class '__main__.C'&gt;之类的print 'c.__class__.__getattribute__', c.__class__.__getattribute__ # 因为c.__class__也是一个对象# &lt;slot wrapper '__getattribute__' of 'object' objects&gt;print 'c.__class__.__mro__', c.__class__.__mro__ # method resolution order C B A Oprint '******'print 'c.x', c.x """父类们寻找顺序是根据c.__class__.__mro__ 来的c先去寻找父类们中有没有x的描述符，没有，然后在自己的__dict__中找x，也咩有，然后再去父类们的__dict__中找有没有这个属性名的non-data 描述符，没有，不是描述符而是直接属性的呢？A中有，返回A中的x值"""print 'c.y', c.y"""同上，父类的顺序不废话了最终在第三阶段找到A中的y，它是一个non-data descriptor，NonDesc: y from cls A"""print 'c.z', c.z"""在第一个阶段中的A中找到z 是一个data descriptor，饭后 DataDesc: z from cls A"""print 'c.nope', c.nope"""当前三个阶段都找不到的时候，如果类中有定义__getattr__，就到这里去，没有报错这里所有三个阶段没有nope属性，然后到了__getattr__，返回 getattr C: nope"""c.t = 't from obj c'c.u = NonDesc('u from obj c')c.v = DataDesc('v from obj c')c.x = 'x from obj c'c.y = NonDesc('y from obj c')c.z = DataDesc('z from obj c')print '******'print 'c.t', c.t"""如上，在第二个阶段找到t, 返回 t from obj c"""print 'c.u', c.u"""在第二个阶段在c字典里面找到，不管是值还是descriptor ，这里会调用__get__() NonDesc: u from obj cupdate:更正因为在"""print 'c.v', c.v"""在第二阶段c字典里找到, 调用__get__() ，返回 DataDesc: v from obj c"""print 'c.x', c.x"""因为在第一阶段是在类父类中找描述符，虽然A中有属性x但不是描述符，因此进入第二个阶段，在实例字典中找，不管是不是描述符只要名字对了就返回. 这里在这个阶段返回x from obj c"""print 'c.y', c.y"""同上，返回的是 NonDesc: y from obj c"""print 'c.z', c.z"""同上，返回的是 DataDesc: z from obj c"""print '******' # 这里是用到 class attribute look up 。 以上是对实例进行点运算print "C.x", C.x"""因为B的metaclass是M了，C继承B，C现在的metaclass也是M现在要将上面的所有概念都升级，原来class变成metaclass，原来instance变成class先根据metaclass里的mro决定先后顺序metaparents因为这里是类属性访问，C类的metaclass是M，M.__mro__ 是 (&lt;class '__main__.M'&gt;, &lt;type 'type'&gt;, &lt;type 'object'&gt;)按顺序找x的描述符，但M中没有x的描述符，然后type，object都没有。进入第二个阶段，先计算C.__mro__,按照顺序依次访问类字典C,B,A,O ， 如果有属性重名，先要描述符，不然只要是在__dict__中就返回c中没有x,然后去B，B里面也咩有x，到A中，有x但是不是描述符，没关系直接返回,因为也没有名字为x的描述符了。返回x from A"""print "C.y", C.y"""同上，虽然在M中有y但是是非数据描述符，在第2阶段中的A类中找到y非数据描述符,返回 NonDesc: y from cls A"""print "C.z", C.z"""这是在第一个阶段中的M里找到z数据描述符， 返回 DataDesc: z from cls M"""print "C.nope", C.nope"""上面三个阶段都没有，进入第四个阶段，这个阶段不是去C中的__getattr__，因为上面说了都升了一级，现在是在M中的__getattr__，如果M里面没有__getattr__，那么就回报错，现在M有，返回 getattr M nope"""C.t = 't from obj C'C.u = NonDesc('u from obj C')C.v = DataDesc('v from obj C')C.x = 'x from obj C'C.y = NonDesc('y from obj C')C.z = DataDesc('z from obj C')"""如果是类属性访问，好像没有A，B什么事 !!!!写在流程搞错之前，之前在第二阶段没有计算类的__mro__重新看一下流程"""print '******'print "C.t", C.t"""因为metaclass以及mro中都没有t，进入下一个阶段在第二阶段中现在C类中有t这个属性了，返回 t from obj C"""print "C.u", C.u"""同上，在第二阶段中C类的__dict__中找到，返回 NonDesc: u from obj C"""print "C.v", C.v"""同上，在第二阶段中返回 DataDesc: v from obj C"""print "C.x", C.x"""和M中有重名，但是因为M中的不是数据描述符，这个的优先级高，在第二阶段返回 x from obj C虽然A中也有x，但是mro顺序C排在A前面"""print "C.y", C.y"""同上，有重名，但是M中是非数据描述符，第一阶段过，到第二阶段，返回 NonDesc: y from obj C然后A中同理"""print "C.z", C.z"""重名，但是z在M中是数据描述符，在第一阶段就返回 DataDesc: z from cls M"""print "C.nope", C.nope"""这个没有变 getattr M nope""" 结果：1234567891011121314151617181920212223242526272829******c.__class__ &lt;class '__main__.C'&gt;c.__class__.__getattribute__ &lt;slot wrapper '__getattribute__' of 'object' objects&gt;c.__class__.__mro__ (&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)******c.x x from Ac.y NonDesc: y from cls Ac.z DataDesc: z from cls Ac.nope getattr C: nope******c.t t from obj cc.u &lt;__main__.NonDesc object at 0x1009b8f10&gt;c.v &lt;__main__.DataDesc object at 0x1009b8f50&gt;c.x x from obj cc.y &lt;__main__.NonDesc object at 0x1009b8f90&gt;c.z DataDesc: z from cls A******C.x x from AC.y NonDesc: y from cls AC.z DataDesc: z from cls MC.nope getattr M nope******C.t t from obj CC.u NonDesc: u from obj CC.v DataDesc: v from obj CC.x x from obj CC.y NonDesc: y from obj CC.z DataDesc: z from cls MC.nope getattr M nope]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[descriptor]]></title>
      <url>%2F2017%2F03%2F08%2Fdescriptor%2F</url>
      <content type="text"><![CDATA[其实自己没有深入的研究源码，这篇也是基于阅读一些官方文档和他人的博客做的总结。我这里的思路是从描述符的渊源到为什么有这个描述符，然后怎么用这里先直接给出描述符的定义，先有个印象，如果一开始阅读感觉没什么联系，没关系，最终那些点将连成线的。官方的定义： In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are get(), set(), and delete(). If any of those methods are defined for an object, it is said to be a descriptor.from – Descriptor HowTo Guide 也就是只要一个类定义了__get__(),__set__(),__delete__()当中的任意一个特殊方法,这个类就有了个别名“描述符”啦 描述符的由来首先，因为python是一种动态编译的语言，他能在运行中动态添加类属性或类对象属性。那这些属性是被保存在比如a.__dict__这个里面，这里a是一个实例a=A()。其实类也有一个__dict__属性，通过A.__dict__就可以访问到. 123456789101112131415&gt;&gt;&gt; class A(object):... def __init__(self):... self.attr = 1... def foo(self):... print self.attr...&gt;&gt;&gt; a = A()&gt;&gt;&gt; dir(a)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'attr', 'foo']&gt;&gt;&gt; dir(A)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo']&gt;&gt;&gt; a.__dict__&#123;'attr': 1&#125;&gt;&gt;&gt; A.__dict__dict_proxy(&#123;'__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, 'foo': &lt;function foo at 0x101bba668&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bba5f0&gt;&#125;) 注意到在A类中定义了一个foo函数，像这样的函数在C++语言中被称为成员函数，但是可以看到在a.__dict__中没有foo，在A.__dict__中有。其实通过访问，可以看出a.__dict__中保存的都是一些变量属性。这么理解，在C++中成员函数是被所有对象所共享的，不会为没个对象复制一份，这里也一样，可以看作是类的一个属性，不是实例的属性。那其实在python中，这么做是牵涉到了它的另外的两个概念，绑定，未绑定函数和描述符。先说一下，所有的类成员函数都是non-data despriptor。后面会继续解释 In a nutshell, a descriptor is a way to customize what happens when you reference an attribute on a model.from – Python Descriptors, Part 1 of 2 Descriptor are the mechanism behind properties, methods, static methods, class methods and super()from – Descriptor HowTo Guide 访问属性[Todo] 这里将访问属性的另做一个页面把建议先把下面的看了再来看这个 我之所以说先看下面，又不得不把这个主题先放上来，是因为其实描述符归根结底，目前看到就是对属性的取值赋值操作，只不过是对这个操作封装了一下而已。12a.attr = 1tmp = a.attr 一般的取值赋值就是这样子的，如果attr事先在类里面定义好了的self.attr = arg 上面的a.attr = 1其实就是重新将“标签”a.attr贴到1数值上去，如果没有那就是动态生成attr属性。但是这样的赋值太单一了，什么意思，也就是说，如果我要对赋入的值做下额外的检查，比如学生的成绩，不可能出现负数，身高也不可能出现负数。所以想到了在__init__当中增加一些逻辑代码进行检查123def __init__(self,score): assert score&gt;=0,"value error" self.score = score 但是这样只是在初始化的时候，像a = A(-1)会报错，那之后如果a.score = -100像这样的误操作，也没人阻止。那我们又有了另一种思路123456def get_score(self): return self.scoredef set_score(self,new_score): assert new_score&gt;=0,"value error" self.score = new_score 通过a.set_score(-100)，调用一个函数，并在函数体内进行检查来进行赋值。 总的来讲，python的属性获取，设置，这个属性只是一个存储的地方，只是一个容器，但往往你可能需要更多的功能，比如赋值的时候检验，然后，一般的，是用一些方法来做这些事情，但是如果对于已经存在了的属性，你想用函数代替取值，赋值，你就要重写代码，找到所有用到这些属性的方法，然后改成函数，比如上面的所有a.score = 1像这样的操作改成a.set_score(1)。这样就增加了工作量，这也是为什么在java程序中一个简单的取值都要封装成一个函数，就是为了避免何种情况，常见的模式也就是属性定义为私有变量，然后开放一个公有接口。python中的描述符只不过是另一种方法来实现这种对属性额外控制的需求而已 描述符实例描述符的用法应该不局限于下面给出的例子，要多看其他高人的代码！！！12345678910111213class Positive(object): def __init__(self,name): self.name = name def __get__(self,instance,owner): if instance is None: return self #这里相当于如果通过类调用,Student.score，就返回是类似&lt;descriptor.Positive object at 0x123455..&gt;之类的 return instance.__dict__[self.name] def __set__(self,instance,value): if value &lt; 0: raise ValueError("negative value error...") instance.__dict__[self.name] = value 上面就定义了一个描述符。其实就是一个类，描述符只是个名称而已。在我的世界里，我想叫它皮皮虾都可以。只是全世界就这么流通规定了12345class Student(object): score = Positive('score') #这句话就将score属性让描述符代理了 def __init__(self,name,score): self.name = name self.score = score 现在如果有这么一个语句s = Student(&#39;cy&#39;,100);a = s.score，其实是相当于在做a = type(s).__dict__[&#39;score&#39;].__get__(s,type(s))可以查看Student.__dict__中的score属性是&#39;score&#39;: &lt;__main__.Positive object at 0x101bb8ed0&gt;这样子的。当作了type(s).__dict__[&#39;score&#39;]时其实就是获得了一个实例，之后还可以继续用点运算符往下接着做。 Q&amp;APositive 描述符中的__set__为什么参数中没有类？1234567&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': &lt;__main__.Positive object at 0x101bb8ed0&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;)#注意上面的score属性的值&gt;&gt;&gt; Student.score = 12 # 通过类访问&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': 12, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;)#再对比一下score的值 当类调用的时候，其实就是设置同名新值了，它将原来的描述符给替换覆盖了。 Student类里面的score和self.score,到底用的是哪个？？可以先看一下12345&gt;&gt;&gt; s = Student('cy','100')&gt;&gt;&gt; s.__dict__&#123;'score': '100', 'name': 'cy'&#125;&gt;&gt;&gt; Student.__dict__dict_proxy(&#123;'__module__': '__main__', 'score': &lt;__main__.Positive object at 0x101bb8ed0&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x101bbaaa0&gt;&#125;) 其实这里涉及到一个优先级的问题，也就是上面的访问属性的顺序链接。这里可以再跳回去看。因为描述符的优先级高！并且会改变默认的get,set方法。 If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has entry with the same name as a non-data descriptor,the dictionary entry takes precedence.from Descriptor HowTo Guide 什么是non-data descriptor后面会说明。 2引申的一个问题就是如果self.score = score没有定义会是什么情况1234567891011121314&gt;&gt;&gt; class Student(object):... score = Positive('score')... def __init__(self,name):... self.name = name...&gt;&gt;&gt; s = Student('cy')&gt;&gt;&gt; s.score = 10&gt;&gt;&gt; s.__dict__&#123;'score': 10, 'name': 'cy'&#125;&gt;&gt;&gt; s.score = -10Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 10, in __set__ValueError: negative error 还是照样行得通。因为instance.__dict__[self.name] = value.虽然初始化的时候没有score这个属性，但其实后面的字典操作，相当于动态增加了这个属性，而且访问的优先级照样根据那个顺序来 如果是self.score = Positive(&#39;score&#39;)会怎么样1234567891011&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... self.score = Positive('score')...&gt;&gt;&gt; s = Student('cy')&gt;&gt;&gt; s.__dict__&#123;'score': &lt;__main__.Positive object at 0x101bc70d0&gt;, 'name': 'cy'&#125;&gt;&gt;&gt; s.score = -10&gt;&gt;&gt; s.__dict__&#123;'score': -10, 'name': 'cy'&#125; 没有起到作用，这是必然的。如果你知道访问顺序了之后，访问s.score时，因为类中没有同名的描述符，所以到实例中的__dict__看，如果有这个key，返回，但这里是赋值操作，参考另一篇python name and values，s.scorei = -10只不过是将score这个name重新贴标签贴到数值-10上去。 __get__中参数owner什么用，也没有用到它啊？后面在classmethod中就会用到这个参数。其实函数参数写在哪里，也不一定都要用到，但更关心为什么要这么设计。后面看看源代码 看一个图： 应用场景python中有个叫修饰器的东西，property()，它是描述符的简介版123456789@propertydef score(self): return self.__score@score.setterdef score(self,score): if score &lt; 0: raise ValueError('negative') self.__score = score calling propery() is a succinct way of building a data descriptor that triggers function calls upon access to an attributefrom Descriptor HowTo Guide 上面的写法@property使用到了装饰器 但是如果一个类里面有很多属性是相同的限制，比如学生的身高不能负数，成绩不能负数，体重不能负数，如果用property的话，那就多了很多重复的代码，每个属性都要像上面一样写一遍。这时候就可以考虑用写一个描述符类来“一统天下”了 在之前说的对于已存在的属性，如果要对它们要进行限制，通过方法的话要找到每一处，这样很不方便，如果使用描述符只需要在类中加上tall = Positive(&#39;tall&#39;)像这样的语句就可以了，而且完全没有任何副作用！！ If looked-up value is an object defining one of the descriptor methods, then python may override the default behavior and invoke the descriptor method instead.from Descriptor HowTo Guide 描述符的种类 学习也要遵循20/80定律，学到的20%就足够写程序了，先跑起来再来完善接下来的80%– 尔东诚霍划夫斯基描述符分data descriptor和non-data descriptor两者之前的区别就是，后者只定义了__get__。也就是没有设置。]]></content>
    </entry>

    
  
  
</search>
