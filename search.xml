<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[python name and values]]></title>
      <url>http://www.mmmmmcclxxvii.cn/2017/03/29/python-name-and-values/</url>
      <content type="html"><![CDATA[<p>阅读 <a href="https://nedbatchelder.com/text/names.html" target="_blank" rel="external">Facts and myths about Python names and values</a> 做的摘记<br>内容不是很深，只是这里面提到了一些需要注意的点。最主要还是<code>name</code>和<code>value</code>的区别<br><a id="more"></a></p>
<h1 id="Fact-Names-have-no-type-values-have-no-scope"><a href="#Fact-Names-have-no-type-values-have-no-scope" class="headerlink" title="Fact: Names have no type, values have no scope."></a>Fact: Names have no type, values have no scope.</h1><blockquote>
<p>Just as names have no type, values have no scope. When we say that a function has a local variable, we mean that the name is scoped to the function: you can’t use the name outside the function, and when the function returns, the name is destroyed. But as we’ve seen, if the name’s value has other references, it will live on beyond the function call. It is a local name, not a local value.</p>
</blockquote>
<p>翻译：</p>
<p>就跟名字没有类型一样，数值是没有作用范围的。当我们说一个函数有局部变量的时候，我们只是说的是名字只在函数作用域中起作用而已，你不能在函数外使用这个名字，当函数返回的时候，这个名字也就摧毁了。但是，如果这个名字指向的数值还有其他引用，它就会继续生存下去，不管这个函数了。局部变量，而不是局部数值。</p>
<h1 id="Fact-Values-can’t-be-deleted-only-names-can"><a href="#Fact-Values-can’t-be-deleted-only-names-can" class="headerlink" title="Fact: Values can’t be deleted, only names can."></a>Fact: Values can’t be deleted, only names can.</h1><blockquote>
<p>Python’s memory management is so central to its behavior, not only do you not have to delete values, but there is no way to delete values. You may have seen the del statement:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">del</span> nums</div></pre></td></tr></table></figure>
<blockquote>
<p>This does not delete the value nums, it deletes the name nums. The name is removed from its scope, and then the usual reference counting kicks in: if nums’ value had only that one reference, then the value will be reclaimed. But if it had other references, then it will not.</p>
</blockquote>
<h1 id="Fact-Assignment-never-copies-data"><a href="#Fact-Assignment-never-copies-data" class="headerlink" title="Fact: Assignment never copies data."></a>Fact: Assignment never copies data.</h1><blockquote>
<p>Mutable means that the value has methods that can change the value in-place. Immutable means that the value can never change, instead when you think you are changing the value, you are really making new values from old ones.</p>
</blockquote>
<p>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">3</span></div><div class="line">y = x</div></pre></td></tr></table></figure></p>
<p><code>x</code>和<code>y</code>只是一起指向了<code>3</code>而已，并没有给<code>y</code>再来一个<code>3</code>。这里<code>x</code>,<code>y</code>是<code>name</code>，<code>3</code>是<code>value</code><br>上面说到的<code>Mutable</code>是什么意思，也就是因为这个赋值不拷贝数据的特性，当<code>y</code>变了的时候，比如<code>y+=1</code>，那<code>x</code>还变不变？这里就要考虑到可变类型和不可变类型了</p>
<p>Immutable values:</p>
<ol>
<li>numbers</li>
<li>strings</li>
<li>tuples </li>
</ol>
<p>Mutable values:</p>
<ol>
<li>lists</li>
<li>dicts</li>
<li>user-defined objects</li>
</ol>
<p>那在上面<code>y+=1</code>之后，其实是给<code>y</code>重新<code>reference</code>到了4</p>
<p>关于mutable的直接截图：</p>
<p><img src="http://onexs3cnv.bkt.clouddn.com/list_mutate_value.png" alt="list_mutate"></p>
<hr>
<h1 id="Fact-Python-passes-function-arguments-by-assigning-to-them"><a href="#Fact-Python-passes-function-arguments-by-assigning-to-them" class="headerlink" title="Fact: Python passes function arguments by assigning to them."></a>Fact: Python passes function arguments by assigning to them.</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def my_func(x,y)</div><div class="line">	return x+y</div><div class="line">print(my_func(8,9))</div></pre></td></tr></table></figure>
<blockquote>
<p>The names x and y are local to the function, so when the function returns, those names go away. But if the values they refer to are still referenced by other names, the values live on.</p>
</blockquote>
<p><strong>注意</strong>，这里就出现<code>name</code>和<code>value</code>的区别了，可以这样理解，<code>value</code>就是一个实物，<code>name</code>只是这个实物的标签，我可以贴很多标签，而看到这个标签，我就联想到这个实物，实物可以有多个标签，一个标签只能对应一个实物。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">augment_twice</span><span class="params">(a_list,val)</span>:</span></div><div class="line">	a_list.append(val)</div><div class="line">	a_list.append(val)</div><div class="line"></div><div class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">augment_twice(nums, <span class="number">4</span>)</div><div class="line">print(nums) <span class="comment">#[1,2,3,4,4]</span></div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-29%20at%2010.23.49%20PM.png" alt="before"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-29%20at%2010.23.55%20PM.png" alt="after"></h2><p>虚线框表示本地<code>name</code>在一个新的<code>frame</code>里面，而参数传递只是一种赋值操作，<code>a_list</code> “指向” <code>nums</code>指向的<code>value</code>,而<code>list</code>类型是可变数据类型，所以任何<code>name</code>对它的改变都是就地的，可以通过<code>id()</code>操作来查看是否改变了地址</p>
<p>另外一个程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">augment_twice_bad</span><span class="params">(a_list,val)</span>:</span></div><div class="line">	a_list = a_list + [val,val]</div><div class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">augment_twice_bad(nums,<span class="number">4</span>)</div><div class="line">print(nums) <span class="comment">#[1,2,3]</span></div></pre></td></tr></table></figure>
<p>这个跟上面的程序就不同在函数里面一个是用<code>.append()</code>来增加元素，一个则用加法然后赋值，赋值，赋值，重要的事情说三遍，这是个赋值操作，一旦出现赋值，就相当于等式左边的<code>name</code><strong>rebind</strong>出现在等式右边的<code>value</code></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-29%20at%2010.35.39%20PM.png" alt="bad_before"></h2><p><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-29%20at%2010.35.45%20PM.png" alt="bad_after"></p>
<blockquote>
<p>It’s really important to keep in mind the difference between mutating a value in place, and rebinding a name. augment_twice worked because it mutated the value passed in, so that mutation was available after the function returned. augment_twice_bad used an assignment to rebind a local name, so the changes weren’t visible outside the function.</p>
</blockquote>
<h1 id="其他的-facts-myths都知道了，上面的需要注意一下就可以了。过"><a href="#其他的-facts-myths都知道了，上面的需要注意一下就可以了。过" class="headerlink" title="其他的 facts, myths都知道了，上面的需要注意一下就可以了。过"></a>其他的 facts, myths都知道了，上面的需要注意一下就可以了。过</h1>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[project of stackoverflow - python object(一)]]></title>
      <url>http://www.mmmmmcclxxvii.cn/2017/03/14/object/</url>
      <content type="html"><![CDATA[<h1 id="what-does-‘super’-do-in-python"><a href="#what-does-‘super’-do-in-python" class="headerlink" title="what does ‘super’ do in python"></a><a href="http://stackoverflow.com/questions/222877/what-does-super-do-in-python" target="_blank" rel="external">what does ‘super’ do in python</a></h1><p>下面两个的区别是？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(SomeBaseClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(Child, self).__init__()</div></pre></td></tr></table></figure>
<p>和<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(SomeBaseClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		SomeBaseClass.__init__(self)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我在单个继承中已经看到<code>super</code> 被用的很多了。我能知道为什么要在多重继承的时候用它，但是还是不清楚在这种情况用它的好处。</p>
<hr>
<p>180票的回答：（John Millikin)</p>
<p>在单一继承用<code>super</code>的好处很小–只是你不再需要硬编码基类名字到方法里面去了</p>
<p>然后，在多重继承里，不用<code>super()</code>几乎是不可能的。这包括常见的习语，像是mixins，interface,abstract classes等，<br>这能让你的代码在之后延伸。如果以后有人想写一个拓展<code>Child</code> 和 mixin的类，他们的代码不会很好的工作。</p>
<hr>
<p>75票的回答：</p>
<p><strong>区别是什么？</strong></p>
<p><code>SomeBaseClass.__init__(self)</code>意思是调用<code>SomeBaseClass</code>的<code>__init__</code>方法<br>然后，<code>super(Child,self).__init__()</code>意思是从<code>Child</code>类的MRO的父类中调用一个绑定方法<code>__init__</code><br>如果实例是Child的子类，有可能在方法解释顺序中的下一个父类是不一样的？？？</p>
<p><strong>向前兼容间接 ？？ （Indirection with Forward Compatibility) </strong></p>
<p>这能给你什么？对于单重继承，问题中给出的例子几乎等同于静态分析。然而使用<code>super</code> 提供了具有向前兼容性的间接层<br>向前兼容对于经验丰富的开发者来说是很重要的。你希望你的代码在做出一些细微的改动之后还能工作。当您查看修订历史记录时，您希望准确地查看何时更改了哪些内容。</p>
<p>你可能先从单重继承开始，但是当你增加另外的基类，你只需要改变基类的顺序（change the line with the bases）<br>（if the bases change in a class you inherit from）如果类继承关系变了（比如增加了一个mixin)，其实你就没做什么改变。<br>尤其在python2中，要想给super正确的方法参数是很难的。如果你知道你在单重继承下正确的使用<code>super</code>，这样是的调试就容易一点了</p>
<p><strong>依赖注入 Dependency Injection </strong></p>
<p>其他人可以使用你的代码然后插入一些父类到方法解释中(method resolution):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBaseClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'SomeBaseClass.__init__(self) called'</span>)</div><div class="line">			</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsuperChild</span><span class="params">(SomeBaseClass)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'UnsuperChild.__init__(self) called'</span>)</div><div class="line">		SomeBaseClass.__init__(self)</div><div class="line">							</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperChild</span><span class="params">(SomeBaseClass)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'SuperChild.__init__(self) called'</span>)</div><div class="line">		super(SuperChild, self).__init__()</div></pre></td></tr></table></figure>
<p>现在你增加其他类，然后在Foo和Bar之间插入一个类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjectMe</span><span class="params">(SomeBaseClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'InjectMe.__init__(self) called'</span>)</div><div class="line">		super(InjectMe, self).__init__()</div><div class="line">				</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsuperInjector</span><span class="params">(UnsuperChild, InjectMe)</span>:</span> <span class="keyword">pass</span></div><div class="line">					</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperInjector</span><span class="params">(SuperChild, InjectMe)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>使用un-super子类未能注入依赖，因为你是用的子类在自己执行打印后调用的是硬编码方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>o = UnsuperInjector()</div><div class="line">UnsuperChild.__init__(self) called</div><div class="line">SomeBaseClass.__init__(self) called</div></pre></td></tr></table></figure>
<p>然而使用<code>super</code>的子类能正确的依赖注入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = SuperInjector()</div><div class="line">SuperChild.__init__(self) called</div><div class="line">InjectMe.__init__(self) called</div><div class="line">SomeBaseClass.__init__(self) called</div></pre></td></tr></table></figure>
<p>(我：因为super按照MRO来寻找next类的，不是就是去找父类SomeBaseClass,<br>因为SuperInjector的MRO是自身&gt; UnsuperChild &gt; InjectMe &gt; SomeBaseClass &gt; object</p>
<p>还有就是 super 不是在SuperChild内么，为什么要按SuperInjector的MRO来？？<br>这里应该是因为SuperInjector的init没有定义，然后是用的supserchild的，但是还是按照自身的MRO来。<br>怎么做实验</p>
<p>)</p>
<p><strong>结论</strong><br>一直使用<code>super</code>来引用父类就好了</p>
<p>你想要引用的父类是MRO下一个类，而不是你看到的继承的关系</p>
<p>不使用<code>super</code> 回让你代码的使用者多了很多不必要的限制</p>
<hr>
<h1 id="我的："><a href="#我的：" class="headerlink" title="我的："></a>我的：</h1><p>一个例子就是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections imoprt Counter, OrderedDict</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedCounter</span><span class="params">(Counter, OrderedDict)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line">oc = OrderedCounter(<span class="string">"abracadabra"</span>)</div></pre></td></tr></table></figure></p>
<p>之前还一直奇怪这个为什么类里面pass，什么都不用写就能结合，现在知道是因为有super<br>相当于我先把参数传递到Counter初始化，然后因为有super找到的是下一个MRO，然后到OrderedDict初始化<br>相当于两个工序，先count再order。</p>
<hr>
<h1 id="How-does-Python’s-super-actually-work-in-the-general-case"><a href="#How-does-Python’s-super-actually-work-in-the-general-case" class="headerlink" title="How does Python’s super() actually work, in the general case?"></a><a href="http://stackoverflow.com/questions/33290894/how-does-pythons-super-actually-work-in-the-general-case/33291315?noredirect=1#comment72867412_33291315" target="_blank" rel="external">How does Python’s super() actually work, in the general case?</a></h1><p>现在有很多有关<code>super()</code>的资源，包括<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">这个</a>博客写的，还有很多stackoverflow上的问题。但是我感觉它们都没有解释它在普遍情况下是怎么工作的，也就是底层的实现。</p>
<p>考虑下面的这个继承层次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'A foo'</span></div><div class="line">			</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'B foo before'</span></div><div class="line">		super(B, self).foo()</div><div class="line">		<span class="keyword">print</span> <span class="string">'B foo after'</span></div><div class="line">										</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'C foo before'</span></div><div class="line">		super(C, self).foo()</div><div class="line">		<span class="keyword">print</span> <span class="string">'C foo after'</span></div><div class="line">																	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'D foo before'</span></div><div class="line">		super(D, self).foo()</div><div class="line">		<span class="keyword">print</span> <span class="string">'D foo after'</span></div></pre></td></tr></table></figure>
<p>如果你读过python的方法解释顺序的规则，你就知道上面的MRO是（D,B,C,A,object)。 这是被D.<strong>mro</strong>决定的<br><code>(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;type &#39;object&#39;&gt;))</code></p>
<p>和<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = D()</div><div class="line">d.foo()</div></pre></td></tr></table></figure></p>
<p>打印出的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">D foo before</div><div class="line">B foo before</div><div class="line">C foo before</div><div class="line">A foo</div><div class="line">C foo after</div><div class="line">B foo after</div><div class="line">D foo after</div></pre></td></tr></table></figure>
<p>结果符合MRO。 但是，考虑上面的B中的<code>super(B,self).foo()</code> 实际调用的是<code>C.foo</code>，这个是在<code>b=B()</code>中；<code>b.foo()</code> 会直接到<code>A.foo</code> 很显然使用<code>super(B,self).foo()</code>不是<code>A.foo(self)</code>的快捷键，虽然有时是</p>
<p>很显然<code>super()</code>是有意识的在意之前的调用，然后尝试着去跟随总的MRO链。我觉得有两个方法能完成这个。<br>第一个是做了一些类似在链中将<code>super</code>对象传递给下一个方法的<code>self</code>参数,像原来<code>self</code>对象那样，但是包含了这个信息，但是这样似乎会破坏很多东西(<code>super(D,d) is d</code>是False)，然后做了一些实验，我觉得这个方法不可行。</p>
<p>另外一个方法是类似全局变量来保存MRO和现在的链上的位置。我想象中的<code>super</code>算法是这样的：</p>
<ol>
<li>我们当前有工作的环境吗？如果没有，创建一个队列，获取MRO，将除了第一个之外的所有元素入队列</li>
<li>将当前上下文的MRO队列中pop一个元素，在构建<code>super</code>实例的时候将它作为当前的class</li>
<li>当访问<code>super</code>实例的一个方法的时候，在当前class上寻找，然后调用它</li>
</ol>
<p>但是，这样却没有解释类似使用不一样的基类当作第一个参数来调用<code>super</code>，或者调用不同方法。（这段好别扭）<br>我想知道这个的更普遍的算法。而且，如果这样的context存在的话，我能看吗？我能破坏他么？这当然是一个糟糕的想法，但是python希望你成为一个成熟的人尽管你不是。</p>
<p>这同样也引入了好多设计的考量。如果我写的B只考虑了它和A的联系，然后又有其他人写了C，还有其他人写了D，我的<code>B.foo()</code>方法必须找到一个能兼容<code>C.foo()</code>的方法来调用<code>super</code>，尽管我在写它的时候C不存在。如果我想要我的类能很简单的扩展，那我必须要考虑这些。但是我不清楚这是不是比简单的将所有的<code>foo</code>的特征设置成一样来的更复杂。还有一个问题就是什么时候将代码放在<code>super</code>之前，什么时候之后，即使在仅考虑B的基类的时候它没有什么区别</p>
<hr>
<p>7票的回答：</p>
<blockquote>
<p>super() is then obviously aware of the previous calls before it</p>
</blockquote>
<p>它不是。当你做<code>super(B,self).foo</code>,<code>super</code>知道你的MRO因为它会从<code>type(self).__mro__</code>中得到。然后它知道应该在MRO的B后面那里开始寻找<code>foo</code>，一个粗略的纯 python写的应该是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">super</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, klass, obj)</span>:</span></div><div class="line">		self.klass = klass</div><div class="line">		self.obj = obj</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attrname)</span>:</span></div><div class="line">		classes = iter(type(self.obj).__mro__)</div><div class="line"></div><div class="line">		<span class="comment"># search the MRO to find self.klass</span></div><div class="line">		<span class="keyword">for</span> klass <span class="keyword">in</span> classes:</div><div class="line">			<span class="keyword">if</span> klass <span class="keyword">is</span> self.klass:</div><div class="line">				<span class="keyword">break</span></div><div class="line"></div><div class="line">		<span class="comment"># start searching for attrname at the next class after self.klass</span></div><div class="line">		<span class="keyword">for</span> klass <span class="keyword">in</span> classes:</div><div class="line">			<span class="keyword">if</span> attrname <span class="keyword">in</span> klass.__dict__:</div><div class="line">				attr = klass.__dict__[attrname]</div><div class="line">				<span class="keyword">break</span></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">raise</span> AttributeError</div><div class="line"></div><div class="line">		<span class="comment"># handle methods and other descriptors</span></div><div class="line">		<span class="keyword">try</span>:</div><div class="line">			<span class="keyword">return</span> attr.__get__(self.obj, type(self.obj))</div><div class="line">		<span class="keyword">except</span> AttributeError:</div><div class="line">			<span class="keyword">return</span> attr</div></pre></td></tr></table></figure></p>
<blockquote>
<p>If I wrote B thinking only of its relation to A, then later someone else writes C and a third person writes D, my B.foo() method has to call super in a way that is compatible with C.foo() even though it didn’t exist at the time I wrote it!</p>
</blockquote>
<p>并不要求你要从随机的类中多种继承。除非<code>foo</code>是被特意设计成在多重继承的时候将兄弟类的重写。D不应该存在。</p>
]]></content>
      
        <categories>
            
            <category> stackoverflow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> object </tag>
            
            <tag> stackoverflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[understanding MRO]]></title>
      <url>http://www.mmmmmcclxxvii.cn/2017/03/13/mro/</url>
      <content type="html"><![CDATA[<p>其实我一直觉得遇到什么障碍再去学什么是效率比较高的，这时候是带着问题去解决问题，比起干看，没有与实际相结合，要有用多了。所以等你真正遇到这个问题了，再来看看。<strong> 这个<code>MRO</code>是理解<code>super</code>方法的前序 </strong>,以下考虑的都是多重继承，单重继承讨论这个就没什么价值了。</p>
<h1 id="Method-Resolution-Order"><a href="#Method-Resolution-Order" class="headerlink" title="Method Resolution Order"></a>Method Resolution Order</h1><blockquote>
<p>In computing, the C3 superclass linearization is an algorithm used primarily to obtain the order in which methods should be inherited (the “linearization”) in the presence of multiple inheritance, and is often termed Method Resolution Order (MRO)<br>from wikipedia – <a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="external">C3 linearization</a></p>
</blockquote>
<p>这里引进这个概念。因为在继承中，会有子类继承父类当中的一些元素或方法，但是在多重继承中，到底是哪一个呢？这里就涉及到了<code>MRO</code>，方法解释顺序。可以想像一个列表，里面是继承关系的顺序，当调用子类的方法，或访问子类的元素的时候，就按照这个顺序依次的查找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A,B,C)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>你可以试一下，这个<code>D</code>类是定义不了的，会报错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: Error when calling the metaclass bases</div><div class="line">  Cannot create a consistent method resolution</div><div class="line">order (MRO) <span class="keyword">for</span> bases object, B, C</div></pre></td></tr></table></figure></p>
<p>这里是因为破坏了<code>MRO</code>的一个(<code>monotomic</code>)单调性规定：</p>
<blockquote>
<p>if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C.</p>
</blockquote>
<p>通过C3算法得出的<code>MRO</code>就可以满足上面的这个要求</p>
<h1 id="C3-linearization"><a href="#C3-linearization" class="headerlink" title="C3 linearization"></a>C3 linearization</h1><p>先定义几个符号表示：<br><code>C1C2....CN</code> 表示一个[C1,C2,C3….CN]的解决顺序列表，在这样的一个列表中，<code>head</code>是<code>C1</code>，<strong>其余的</strong>都叫做<code>tail</code>。<br>注意：是从C2到最后都算tail.<br><code>C+(C1C2...CN) = CC1C2...CN</code> 表示<code>[C] + [C1,C2...CN]</code><br><code>L[C]</code>表示<code>linearization of class C</code>，规定<code>L[O] = O</code>,<code>O</code>表示<code>object</code></p>
<p>算法可以描述为一个递归的过程：</p>
<blockquote>
<p>the linearization of C is the Sum of C plus the merge of the linearizations of the parents and the list of the parents.<br><code>L[C(B1B2...BN)] = C + merge(L[B1],...L[BN],B1...BN)</code><br>顺序很重要，一一对应的。</p>
</blockquote>
<p>merge 算法描述为(原文)：</p>
<blockquote>
<p>take the head of the first list, i.e L[B1][0]; if this head is not in the tail of any of the other lists, then add it to the linearization of C and remove it from the lists in the merge, otherwise look at the head of the next list and take it. if it is a good head, then report the operation until all the class are removed or it is impossible to find good heads. If fail, python will refuse to create the class C and will raise an exception.</p>
</blockquote>
<h2 id="没看懂直接看例子。"><a href="#没看懂直接看例子。" class="headerlink" title="没看懂直接看例子。"></a>没看懂直接看例子。</h2><p><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-30%20at%207.18.59%20PM.png" alt="example-class-inherit"></p>
<p>写出各个的<code>linearization</code>（这个翻译成啥我也不知道）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">L[O] = O</div><div class="line">L[E] = EO</div><div class="line">L[D] = DO</div><div class="line">L[F] = FO</div><div class="line">L[B] = B + merge(L[D],L[E],DE)</div><div class="line">     = B + merge(DO,EO,DE)</div></pre></td></tr></table></figure></p>
<p>这里是要<code>merge</code>3个<code>list</code>，<code>DO</code>,<code>EO</code>,<code>DE</code>，从第一个<code>DO</code>开始，它的<code>head</code>是<code>D</code>，然后看<code>D</code>是否出现在其他<code>list</code>的<code>tail</code>中中，注意<code>tail</code>是指除了<code>head</code>其余的所有。比如有一个<code>list</code>是<code>ADCBEF</code>,那<code>D</code>出现在第2个位置也算是在<code>tail</code>中，而不是在最后一个位置才算是<code>tail</code>。也就是说只有<code>D</code>出现在其他<code>list</code>首位置的时候，或者就根本没有<code>D</code>，这个<code>D</code>算是一个<code>good head</code>，然后将<code>D</code>加入<code>B</code>的linearization中，如果<code>D</code>不满足上面的条件，那么顺推到下一个<code>list</code> <code>EO</code>中的<code>E</code>，如果再不满足，继续顺推，都不满足的话就<code>raise an exception</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">L[B] = B + merge(L[D],L[E],DE)</div><div class="line">     = B + merge(DO,EO,DE)</div><div class="line">	 = B + D + merge(O,EO,E) <span class="comment">#再从第一个list O 开始去第一个元素O，但O不满足，出现在了第二个EO的tail中，顺延</span></div><div class="line">	 = B + D + E + merge(O,O)</div><div class="line">	 = B + D + E + O</div><div class="line">	 = BDEO</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L[C] = C + merge(DO,FO,DF)</div><div class="line">	 = C + D + merge(O,FO,F)</div><div class="line">	 = C + D + F + merge(O,O)</div><div class="line">	 = CDFO</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">L[A] = A + merge(L[B],L[C],BC)</div><div class="line">	 = A + merge(BDEO,CDFO,BC)</div><div class="line">	 = A + B + merge(DEO,CDFO,C)</div><div class="line">	 = A + B + C + merge(DEO,DFO)</div><div class="line">	 = A + B + C + D + merge(EO,FO)</div><div class="line">	 = A + B + C + D + E + merge(O,FO)</div><div class="line">	 = A + B + C + D + E + F + merge(O,O)</div><div class="line">	 = A + B + C + D + E + F + O</div><div class="line">	 = ABCDEFO</div></pre></td></tr></table></figure>
<hr>
<h2 id="另一个例子–-不能生成mro"><a href="#另一个例子–-不能生成mro" class="headerlink" title="另一个例子– 不能生成mro"></a>另一个例子– 不能生成mro</h2><p><img src="http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202017-03-30%20at%207.39.09%20PM.png" alt="bad-example"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">L[O] = O</div><div class="line">L[X] = XO</div><div class="line">L[Y] = YO</div><div class="line">L[A] = AXYO </div><div class="line">L[B] = BYXO <span class="comment">#这两个其实也应该通过上面那个merge算法算出来的，只不过这里一眼就能看出来</span></div></pre></td></tr></table></figure>
<p>关键看类C<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">L[C] = C + merge(AXYO,BYXO,AB)</div><div class="line">	 = C + A + merge(XYO,BYXO,B)</div><div class="line">	 = C + A + B + merge(XYO,YXO)</div></pre></td></tr></table></figure></p>
<p>到了这里就做不下去了，这里<code>XYO</code>,<code>YXO</code>，不管第一个<code>X</code>还是第二个的<code>Y</code>，都不行！！</p>
<blockquote>
<p>X is in the tail of YXO whereas Y is in the tail of XYO<br>因此算法结束.<code>raise an error refuese to create class C</code></p>
</blockquote>
<h1 id="快速判别能否生成MRO的方法"><a href="#快速判别能否生成MRO的方法" class="headerlink" title="快速判别能否生成MRO的方法"></a>快速判别能否生成MRO的方法</h1><p>以下来自 <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html" target="_blank" rel="external">python Attributes and Methods</a><br><img src="http://www.cafepy.com/article/python_attributes_and_methods/images/simple_hierarchy.png" alt="simple hierarchy"><br>现在要定义一个新的类<code>class N(A,B,C)</code><br><img src="http://www.cafepy.com/article/python_attributes_and_methods/images/beads_on_strings.png" alt="game abacus style beads"><br>画的稍微歪了，第一排全是<code>O</code>，那ok，<code>result</code>中也生成<code>O</code>放在顶部，第二排，<code>BBC</code>，不一样，要全部一样才能放在最后的<code>result</code>中，所以这个是失败的。</p>
<p>如果将类<code>N</code>的定义改为<code>class N(A,C,B)</code><br><img src="http://www.cafepy.com/article/python_attributes_and_methods/images/beads_on_strings_solved.png" alt="solved-beads on strings"></p>
<hr>
<p>以上深入了解以下这个机制就可以，在编程的时候可以调用<code>__mro__</code>属性来查看一个类的<code>mro</code>，了解这个更有助于你理解你写的程序，比如<code>super</code>，比如描述符当中也会用到这个概念</p>
<hr>
<p>出处：</p>
<ol>
<li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="external">The Python 2.3 Method Resolution Order</a></li>
<li><a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html" target="_blank" rel="external">python Attributes and Methods</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> mro </tag>
            
            <tag> python-object </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[descriptor]]></title>
      <url>http://www.mmmmmcclxxvii.cn/2017/03/08/descriptor/</url>
      <content type="html"><![CDATA[<p>其实自己没有深入的研究源码，这篇也是基于阅读一些官方文档和他人的博客做的总结。<br>我这里的思路是从描述符的渊源到为什么有这个描述符，然后怎么用<br>这里先直接给出描述符的定义，先有个印象，如果一开始阅读感觉没什么联系，没关系，最终那些点将连成线的。<br>官方的定义：</p>
<blockquote>
<p>In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are <strong>get</strong>(), <strong>set</strong>(), and <strong>delete</strong>(). If any of those methods are defined for an object, it is said to be a descriptor.<br>from – <a href="https://docs.python.org/2/howto/descriptor.html#definition-and-introduction" target="_blank" rel="external">Descriptor HowTo Guide</a></p>
</blockquote>
<p>也就是只要一个类定义了<code>__get__()</code>,<code>__set__()</code>,<code>__delete__()</code>当中的任意一个<strong>特殊方法</strong>,这个类就有了个别名“描述符”啦</p>
<h1 id="描述符的由来"><a href="#描述符的由来" class="headerlink" title="描述符的由来"></a>描述符的由来</h1><p>首先，因为python是一种动态编译的语言，他能在运行中动态添加类属性或类对象属性。那这些属性是被保存在比如<code>a.__dict__</code>这个里面，这里<code>a</code>是一个实例<code>a=A()</code>。其实类也有一个<code>__dict__</code>属性，通过<code>A.__dict__</code>就可以访问到.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>            self.attr = <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">print</span> self.attr</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(a)</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'attr'</span>, <span class="string">'foo'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(A)</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'foo'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.__dict__</div><div class="line">&#123;<span class="string">'attr'</span>: <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>A.__dict__</div><div class="line">dict_proxy(&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'foo'</span>: &lt;function foo at <span class="number">0x101bba668</span>&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x101bba5f0</span>&gt;&#125;)</div></pre></td></tr></table></figure>
<p>注意到在<code>A</code>类中定义了一个<code>foo</code>函数，像这样的函数在C++语言中被称为成员函数，但是可以看到在<code>a.__dict__</code>中没有<code>foo</code>，在<code>A.__dict__</code>中有。其实通过访问，可以看出<code>a.__dict__</code>中保存的都是一些变量属性。这么理解，在C++中成员函数是被所有对象所共享的，不会为没个对象复制一份，这里也一样，可以看作是类的一个属性，不是实例的属性。那其实在python中，这么做是牵涉到了它的另外的两个概念，<strong>绑定，未绑定函数</strong>和<strong>描述符</strong>。先说一下，所有的类成员函数都是<strong><code>non-data despriptor</code></strong>。后面会继续解释</p>
<hr>
<blockquote>
<p>In a nutshell, a descriptor is a way to customize what happens when you reference an attribute on a model.<br>from – <a href="http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/" target="_blank" rel="external">Python Descriptors, Part 1 of 2</a></p>
</blockquote>
<hr>
<blockquote>
<p>Descriptor are the mechanism behind properties, methods,  static methods, class methods and <code>super()</code><br>from – <a href="https://docs.python.org/2/howto/descriptor.html#definition-and-introduction" target="_blank" rel="external">Descriptor HowTo Guide</a></p>
</blockquote>
<hr>
<h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h1><p>[Todo] 这里将访问属性的另做一个页面把<br>建议先把下面的看了再来看这个</p>
<p>我之所以说先看下面，又不得不把这个主题先放上来，是因为其实描述符归根结底，目前看到就是对属性的取值赋值操作，<strong>只不过是对这个操作封装了一下</strong>而已。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.attr = <span class="number">1</span></div><div class="line">tmp = a.attr</div></pre></td></tr></table></figure></p>
<p>一般的取值赋值就是这样子的，如果<code>attr</code>事先在类里面定义好了的<code>self.attr = arg</code> 上面的<code>a.attr = 1</code>其实就是重新将“标签”<code>a.attr</code>贴到<code>1</code>数值上去，如果没有那就是动态生成<code>attr</code>属性。<br><strong>但是这样的赋值太单一了，什么意思，也就是说，如果我要对赋入的值做下额外的检查，比如学生的成绩，不可能出现负数，身高也不可能出现负数。所以想到了在<code>__init__</code>当中增加一些逻辑代码进行检查</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,score)</span>:</span></div><div class="line">	<span class="keyword">assert</span> score&gt;=<span class="number">0</span>,<span class="string">"value error"</span></div><div class="line">	self.score = score</div></pre></td></tr></table></figure></p>
<p>但是这样只是在初始化的时候，像<code>a = A(-1)</code>会报错，那之后如果<code>a.score = -100</code>像这样的误操作，也没人阻止。那我们又有了另一种思路<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></div><div class="line">	<span class="keyword">return</span> self.score</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self,new_score)</span>:</span></div><div class="line">	<span class="keyword">assert</span> new_score&gt;=<span class="number">0</span>,<span class="string">"value error"</span></div><div class="line">	self.score = new_score</div></pre></td></tr></table></figure></p>
<p>通过<code>a.set_score(-100)</code>，调用一个函数，并在函数体内进行检查来进行赋值。</p>
<p><strong>总的来讲，python的属性获取，设置，这个属性只是一个存储的地方，只是一个容器，但往往你可能需要更多的功能，比如赋值的时候检验，然后，一般的，是用一些方法来做这些事情，<em>但是如果对于已经存在了的属性，你想用函数代替取值，赋值，你就要重写代码，找到所有用到这些属性的方法，然后改成函数</em>，比如上面的所有<code>a.score = 1</code>像这样的操作改成<code>a.set_score(1)</code>。这样就增加了工作量，这也是为什么在java程序中一个简单的取值都要封装成一个函数，就是为了避免何种情况，常见的模式也就是属性定义为私有变量，然后开放一个公有接口。python中的描述符只不过是另一种方法来实现这种对属性额外控制的需求而已</strong></p>
<h1 id="描述符实例"><a href="#描述符实例" class="headerlink" title="描述符实例"></a>描述符实例</h1><p>描述符的用法应该不局限于下面给出的例子，要多看其他高人的代码！！！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Positive</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line">		self.name = name</div><div class="line">		</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self,instance,owner)</span>:</span></div><div class="line">		<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">			<span class="keyword">return</span> self <span class="comment">#这里相当于如果通过类调用,Student.score，就返回是类似&lt;descriptor.Positive object at 0x123455..&gt;之类的</span></div><div class="line">		<span class="keyword">return</span> instance.__dict__[self.name]</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self,instance,value)</span>:</span></div><div class="line">		<span class="keyword">if</span> value &lt; <span class="number">0</span>:</div><div class="line">			<span class="keyword">raise</span> ValueError(<span class="string">"negative value error..."</span>)</div><div class="line">		instance.__dict__[self.name] = value</div></pre></td></tr></table></figure></p>
<p>上面就定义了一个描述符。其实就是一个类，描述符只是个名称而已。在我的世界里，我想叫它皮皮虾都可以。只是全世界就这么流通规定了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">	score = Positive(<span class="string">'score'</span>) <span class="comment">#这句话就将score属性让描述符代理了</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></div><div class="line">		self.name = name</div><div class="line">		self.score = score</div></pre></td></tr></table></figure></p>
<p>现在如果有这么一个语句<code>s = Student(&#39;cy&#39;,100);a = s.score</code>，其实是相当于在做<code>a = type(s).__dict__[&#39;score&#39;].__get__(s,type(s))</code><br>可以查看<code>Student.__dict__</code>中的<code>score</code>属性是<code>&#39;score&#39;: &lt;__main__.Positive object at 0x101bb8ed0&gt;</code>这样子的。<br>当作了<code>type(s).__dict__[&#39;score&#39;]</code>时其实就是获得了一个实例，之后还可以继续用点运算符往下接着做。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Positive-描述符中的-set-为什么参数中没有类？"><a href="#Positive-描述符中的-set-为什么参数中没有类？" class="headerlink" title="Positive 描述符中的__set__为什么参数中没有类？"></a>Positive 描述符中的<code>__set__</code>为什么参数中没有类？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.__dict__</div><div class="line">dict_proxy(&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'score'</span>: &lt;__main__.Positive object at <span class="number">0x101bb8ed0</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x101bbaaa0</span>&gt;&#125;)</div><div class="line"><span class="comment">#注意上面的score属性的值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.score = <span class="number">12</span>  <span class="comment"># 通过类访问</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.__dict__</div><div class="line">dict_proxy(&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'score'</span>: <span class="number">12</span>, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x101bbaaa0</span>&gt;&#125;)</div><div class="line"><span class="comment">#再对比一下score的值</span></div></pre></td></tr></table></figure>
<p><strong>当类调用的时候，其实就是设置同名新值了，它将原来的描述符给替换覆盖了。</strong></p>
<h3 id="Student类里面的score和self-score-到底用的是哪个？？"><a href="#Student类里面的score和self-score-到底用的是哪个？？" class="headerlink" title="Student类里面的score和self.score,到底用的是哪个？？"></a>Student类里面的score和self.score,到底用的是哪个？？</h3><p>可以先看一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'cy'</span>,<span class="string">'100'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__dict__</div><div class="line">&#123;<span class="string">'score'</span>: <span class="string">'100'</span>, <span class="string">'name'</span>: <span class="string">'cy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.__dict__</div><div class="line">dict_proxy(&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'score'</span>: &lt;__main__.Positive object at <span class="number">0x101bb8ed0</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'Student'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x101bbaaa0</span>&gt;&#125;)</div></pre></td></tr></table></figure></p>
<p>其实这里涉及到一个优先级的问题，也就是上面的访问属性的顺序链接。这里可以再跳回去看。因为描述符的优先级高！并且会改变默认的<code>get</code>,<code>set</code>方法。</p>
<blockquote>
<p>If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has entry with the same name as a non-data descriptor,the dictionary entry takes precedence.<br>from <a href="https://docs.python.org/2/howto/descriptor.html#descriptor-protocol" target="_blank" rel="external">Descriptor HowTo Guide</a></p>
</blockquote>
<p>什么是non-data descriptor后面会说明。</p>
<h3 id="2引申的一个问题就是如果self-score-score没有定义会是什么情况"><a href="#2引申的一个问题就是如果self-score-score没有定义会是什么情况" class="headerlink" title="2引申的一个问题就是如果self.score = score没有定义会是什么情况"></a><code>2</code>引申的一个问题就是如果<code>self.score = score</code>没有定义会是什么情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    score = Positive(<span class="string">'score'</span>)</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line"><span class="meta">... </span>        self.name = name</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'cy'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__dict__</div><div class="line">&#123;<span class="string">'score'</span>: <span class="number">10</span>, <span class="string">'name'</span>: <span class="string">'cy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">-10</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">10</span>, <span class="keyword">in</span> __set__</div><div class="line">ValueError: negative error</div></pre></td></tr></table></figure>
<p>还是照样行得通。因为<code>instance.__dict__[self.name] = value</code>.虽然初始化的时候没有<code>score</code>这个属性，但其实后面的字典操作，相当于动态增加了这个属性，而且访问的优先级照样根据那个顺序来</p>
<h3 id="如果是self-score-Positive-39-score-39-会怎么样"><a href="#如果是self-score-Positive-39-score-39-会怎么样" class="headerlink" title="如果是self.score = Positive(&#39;score&#39;)会怎么样"></a>如果是<code>self.score = Positive(&#39;score&#39;)</code>会怎么样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line"><span class="meta">... </span>        self.name = name</div><div class="line"><span class="meta">... </span>        self.score = Positive(<span class="string">'score'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'cy'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__dict__</div><div class="line">&#123;<span class="string">'score'</span>: &lt;__main__.Positive object at <span class="number">0x101bc70d0</span>&gt;, <span class="string">'name'</span>: <span class="string">'cy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">-10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__dict__</div><div class="line">&#123;<span class="string">'score'</span>: <span class="number">-10</span>, <span class="string">'name'</span>: <span class="string">'cy'</span>&#125;</div></pre></td></tr></table></figure>
<p>没有起到作用，这是必然的。如果你知道访问顺序了之后，访问<code>s.score</code>时，因为类中没有同名的描述符，所以到实例中的<code>__dict__</code>看，如果有这个<code>key</code>，返回，但这里是赋值操作，参考另一篇<a href="http://www.mmmmmcclxxvii.cn/2017/03/29/python-name-and-values/">python name and values</a>，<code>s.scorei = -10</code>只不过是将<code>score</code>这个<strong>name</strong>重新贴标签贴到数值<code>-10</code>上去。</p>
<h3 id="get-中参数owner什么用，也没有用到它啊？"><a href="#get-中参数owner什么用，也没有用到它啊？" class="headerlink" title="__get__中参数owner什么用，也没有用到它啊？"></a><code>__get__</code>中参数<code>owner</code>什么用，也没有用到它啊？</h3><p>后面在<code>classmethod</code>中就会用到这个参数。其实函数参数写在哪里，也不一定都要用到，但更关心为什么要这么设计。后面看看源代码</p>
<p>看一个图：<br><img src="http://onexs3cnv.bkt.clouddn.com/descriptor-example-student.png" alt="descriptor-example-Student"></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>python中有个叫修饰器的东西，<code>property()</code>，它是描述符的简介版<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></div><div class="line">	<span class="keyword">return</span> self.__score</div><div class="line"></div><div class="line"><span class="meta">@score.setter</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self,score)</span>:</span></div><div class="line">	<span class="keyword">if</span> score &lt; <span class="number">0</span>:</div><div class="line">		<span class="keyword">raise</span> ValueError(<span class="string">'negative'</span>)</div><div class="line">	self.__score = score</div></pre></td></tr></table></figure></p>
<blockquote>
<p>calling propery() is a succinct way of building a data descriptor that triggers function calls upon access to an attribute<br>from <a href="https://docs.python.org/2/howto/descriptor.html#properties" target="_blank" rel="external">Descriptor HowTo Guide</a></p>
</blockquote>
<p>上面的写法<code>@property</code>使用到了<a href="">装饰器</a></p>
<ol>
<li>但是如果一个类里面有很多属性是相同的限制，比如学生的身高不能负数，成绩不能负数，体重不能负数，如果用<code>property</code>的话，那就多了很多重复的代码，每个属性都要像上面一样写一遍。这时候就可以考虑用写一个描述符类来“一统天下”了</li>
<li>在之前说的对于已存在的属性，如果要对它们要进行限制，通过方法的话要找到每一处，这样很不方便，如果使用描述符只需要在类中加上<code>tall = Positive(&#39;tall&#39;)</code>像这样的语句就可以了，而且完全没有任何副作用！！</li>
</ol>
<hr>
<blockquote>
<p>If looked-up value is an object defining one of the descriptor methods, then python may override the default behavior and invoke the descriptor method instead.<br>from <a href="https://docs.python.org/2/howto/descriptor.html#definition-and-introduction" target="_blank" rel="external">Descriptor HowTo Guide</a></p>
</blockquote>
<h1 id="描述符的种类"><a href="#描述符的种类" class="headerlink" title="描述符的种类"></a>描述符的种类</h1><blockquote>
<p>学习也要遵循20/80定律，学到的20%就足够写程序了，先跑起来再来完善接下来的80%<br>– 尔东诚霍划夫斯基<br>描述符分<code>data descriptor</code>和<code>non-data descriptor</code><br>两者之前的区别就是，后者只定义了<code>__get__</code>。也就是没有设置。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> descriptor </tag>
            
            <tag> object </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
